package proto

import (
	context "context"
	fmt "fmt"
	strings "strings"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

type SecurityORM struct {
	ClosePrice          uint64
	CurrencyCode        string
	Id                  uint64 `gorm:"type:serial;primary_key;auto_increment"`
	InvestmentAccountId *uint64
	IsCashEquivalent    bool
	SecurityID          string
	SecurityName        string
	SecurityType        string
	TickerSymbol        string
}

// TableName overrides the default tablename generated by GORM
func (SecurityORM) TableName() string {
	return "securities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Security) ToORM(ctx context.Context) (SecurityORM, error) {
	to := SecurityORM{}
	var err error
	if prehook, ok := interface{}(m).(SecurityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.IsCashEquivalent = m.IsCashEquivalent
	to.ClosePrice = m.ClosePrice
	to.CurrencyCode = m.CurrencyCode
	to.SecurityID = m.SecurityID
	to.TickerSymbol = m.TickerSymbol
	to.SecurityType = m.SecurityType
	to.SecurityName = m.SecurityName
	if posthook, ok := interface{}(m).(SecurityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SecurityORM) ToPB(ctx context.Context) (Security, error) {
	to := Security{}
	var err error
	if prehook, ok := interface{}(m).(SecurityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.IsCashEquivalent = m.IsCashEquivalent
	to.ClosePrice = m.ClosePrice
	to.CurrencyCode = m.CurrencyCode
	to.SecurityID = m.SecurityID
	to.TickerSymbol = m.TickerSymbol
	to.SecurityType = m.SecurityType
	to.SecurityName = m.SecurityName
	if posthook, ok := interface{}(m).(SecurityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Security the arg will be the target, the caller the one being converted from

// SecurityBeforeToORM called before default ToORM code
type SecurityWithBeforeToORM interface {
	BeforeToORM(context.Context, *SecurityORM) error
}

// SecurityAfterToORM called after default ToORM code
type SecurityWithAfterToORM interface {
	AfterToORM(context.Context, *SecurityORM) error
}

// SecurityBeforeToPB called before default ToPB code
type SecurityWithBeforeToPB interface {
	BeforeToPB(context.Context, *Security) error
}

// SecurityAfterToPB called after default ToPB code
type SecurityWithAfterToPB interface {
	AfterToPB(context.Context, *Security) error
}

type BalanceORM struct {
	AvailableFunds        float64
	BalanceLimit          uint64
	CreditAccountId       *uint64
	CurrencyCode          string
	CurrentFunds          float64
	DepositAccountId      *uint64
	Id                    uint64 `gorm:"type:serial;primary_key;auto_increment"`
	InvestmentAccountId   *uint64
	MortgageLoanAccountId *uint64
	StudentLoanAccountId  *uint64
}

// TableName overrides the default tablename generated by GORM
func (BalanceORM) TableName() string {
	return "balances"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Balance) ToORM(ctx context.Context) (BalanceORM, error) {
	to := BalanceORM{}
	var err error
	if prehook, ok := interface{}(m).(BalanceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AvailableFunds = m.AvailableFunds
	to.CurrentFunds = m.CurrentFunds
	to.CurrencyCode = m.CurrencyCode
	to.BalanceLimit = m.BalanceLimit
	if posthook, ok := interface{}(m).(BalanceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BalanceORM) ToPB(ctx context.Context) (Balance, error) {
	to := Balance{}
	var err error
	if prehook, ok := interface{}(m).(BalanceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AvailableFunds = m.AvailableFunds
	to.CurrentFunds = m.CurrentFunds
	to.CurrencyCode = m.CurrencyCode
	to.BalanceLimit = m.BalanceLimit
	if posthook, ok := interface{}(m).(BalanceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Balance the arg will be the target, the caller the one being converted from

// BalanceBeforeToORM called before default ToORM code
type BalanceWithBeforeToORM interface {
	BeforeToORM(context.Context, *BalanceORM) error
}

// BalanceAfterToORM called after default ToORM code
type BalanceWithAfterToORM interface {
	AfterToORM(context.Context, *BalanceORM) error
}

// BalanceBeforeToPB called before default ToPB code
type BalanceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Balance) error
}

// BalanceAfterToPB called after default ToPB code
type BalanceWithAfterToPB interface {
	AfterToPB(context.Context, *Balance) error
}

type VirtualAccountORM struct {
	AccessToken           string
	Active                bool
	CreditAccountID       []*CreditAccountORM  `gorm:"foreignkey:VirtualAccountId;association_foreignkey:Id;preload:true"`
	DepositAccountID      []*DepositAccountORM `gorm:"foreignkey:VirtualAccountId;association_foreignkey:Id;preload:true"`
	Id                    uint64
	InvestmentAccountID   []*InvestmentAccountORM   `gorm:"foreignkey:VirtualAccountId;association_foreignkey:Id;preload:true"`
	MortgageLoanAccountID []*MortgageLoanAccountORM `gorm:"foreignkey:VirtualAccountId;association_foreignkey:Id;preload:true"`
	PlaidItemID           string
	StudentLoanAccountID  []*StudentLoanAccountORM `gorm:"foreignkey:VirtualAccountId;association_foreignkey:Id;preload:true"`
	UserID                uint64
}

// TableName overrides the default tablename generated by GORM
func (VirtualAccountORM) TableName() string {
	return "virtual_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *VirtualAccount) ToORM(ctx context.Context) (VirtualAccountORM, error) {
	to := VirtualAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(VirtualAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AccessToken = m.AccessToken
	to.UserID = m.UserID
	for _, v := range m.DepositAccountID {
		if v != nil {
			if tempDepositAccountID, cErr := v.ToORM(ctx); cErr == nil {
				to.DepositAccountID = append(to.DepositAccountID, &tempDepositAccountID)
			} else {
				return to, cErr
			}
		} else {
			to.DepositAccountID = append(to.DepositAccountID, nil)
		}
	}
	for _, v := range m.CreditAccountID {
		if v != nil {
			if tempCreditAccountID, cErr := v.ToORM(ctx); cErr == nil {
				to.CreditAccountID = append(to.CreditAccountID, &tempCreditAccountID)
			} else {
				return to, cErr
			}
		} else {
			to.CreditAccountID = append(to.CreditAccountID, nil)
		}
	}
	for _, v := range m.MortgageLoanAccountID {
		if v != nil {
			if tempMortgageLoanAccountID, cErr := v.ToORM(ctx); cErr == nil {
				to.MortgageLoanAccountID = append(to.MortgageLoanAccountID, &tempMortgageLoanAccountID)
			} else {
				return to, cErr
			}
		} else {
			to.MortgageLoanAccountID = append(to.MortgageLoanAccountID, nil)
		}
	}
	for _, v := range m.StudentLoanAccountID {
		if v != nil {
			if tempStudentLoanAccountID, cErr := v.ToORM(ctx); cErr == nil {
				to.StudentLoanAccountID = append(to.StudentLoanAccountID, &tempStudentLoanAccountID)
			} else {
				return to, cErr
			}
		} else {
			to.StudentLoanAccountID = append(to.StudentLoanAccountID, nil)
		}
	}
	for _, v := range m.InvestmentAccountID {
		if v != nil {
			if tempInvestmentAccountID, cErr := v.ToORM(ctx); cErr == nil {
				to.InvestmentAccountID = append(to.InvestmentAccountID, &tempInvestmentAccountID)
			} else {
				return to, cErr
			}
		} else {
			to.InvestmentAccountID = append(to.InvestmentAccountID, nil)
		}
	}
	to.Active = m.Active
	to.PlaidItemID = m.PlaidItemID
	if posthook, ok := interface{}(m).(VirtualAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VirtualAccountORM) ToPB(ctx context.Context) (VirtualAccount, error) {
	to := VirtualAccount{}
	var err error
	if prehook, ok := interface{}(m).(VirtualAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AccessToken = m.AccessToken
	to.UserID = m.UserID
	for _, v := range m.DepositAccountID {
		if v != nil {
			if tempDepositAccountID, cErr := v.ToPB(ctx); cErr == nil {
				to.DepositAccountID = append(to.DepositAccountID, &tempDepositAccountID)
			} else {
				return to, cErr
			}
		} else {
			to.DepositAccountID = append(to.DepositAccountID, nil)
		}
	}
	for _, v := range m.CreditAccountID {
		if v != nil {
			if tempCreditAccountID, cErr := v.ToPB(ctx); cErr == nil {
				to.CreditAccountID = append(to.CreditAccountID, &tempCreditAccountID)
			} else {
				return to, cErr
			}
		} else {
			to.CreditAccountID = append(to.CreditAccountID, nil)
		}
	}
	for _, v := range m.MortgageLoanAccountID {
		if v != nil {
			if tempMortgageLoanAccountID, cErr := v.ToPB(ctx); cErr == nil {
				to.MortgageLoanAccountID = append(to.MortgageLoanAccountID, &tempMortgageLoanAccountID)
			} else {
				return to, cErr
			}
		} else {
			to.MortgageLoanAccountID = append(to.MortgageLoanAccountID, nil)
		}
	}
	for _, v := range m.StudentLoanAccountID {
		if v != nil {
			if tempStudentLoanAccountID, cErr := v.ToPB(ctx); cErr == nil {
				to.StudentLoanAccountID = append(to.StudentLoanAccountID, &tempStudentLoanAccountID)
			} else {
				return to, cErr
			}
		} else {
			to.StudentLoanAccountID = append(to.StudentLoanAccountID, nil)
		}
	}
	for _, v := range m.InvestmentAccountID {
		if v != nil {
			if tempInvestmentAccountID, cErr := v.ToPB(ctx); cErr == nil {
				to.InvestmentAccountID = append(to.InvestmentAccountID, &tempInvestmentAccountID)
			} else {
				return to, cErr
			}
		} else {
			to.InvestmentAccountID = append(to.InvestmentAccountID, nil)
		}
	}
	to.Active = m.Active
	to.PlaidItemID = m.PlaidItemID
	if posthook, ok := interface{}(m).(VirtualAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type VirtualAccount the arg will be the target, the caller the one being converted from

// VirtualAccountBeforeToORM called before default ToORM code
type VirtualAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *VirtualAccountORM) error
}

// VirtualAccountAfterToORM called after default ToORM code
type VirtualAccountWithAfterToORM interface {
	AfterToORM(context.Context, *VirtualAccountORM) error
}

// VirtualAccountBeforeToPB called before default ToPB code
type VirtualAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *VirtualAccount) error
}

// VirtualAccountAfterToPB called after default ToPB code
type VirtualAccountWithAfterToPB interface {
	AfterToPB(context.Context, *VirtualAccount) error
}

type DepositAccountORM struct {
	AccountName      string
	AccountSubtype   string
	AccountType      string
	BalanceID        *BalanceORM `gorm:"foreignkey:DepositAccountId;association_foreignkey:Id;preload:true"`
	Id               uint64
	PlaidAccountID   string
	VirtualAccountId *uint64
}

// TableName overrides the default tablename generated by GORM
func (DepositAccountORM) TableName() string {
	return "deposit_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DepositAccount) ToORM(ctx context.Context) (DepositAccountORM, error) {
	to := DepositAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(DepositAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountID = m.PlaidAccountID
	to.AccountSubtype = m.AccountSubtype
	to.AccountType = m.AccountType
	to.AccountName = m.AccountName
	if m.BalanceID != nil {
		tempBalanceID, err := m.BalanceID.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.BalanceID = &tempBalanceID
	}
	if posthook, ok := interface{}(m).(DepositAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DepositAccountORM) ToPB(ctx context.Context) (DepositAccount, error) {
	to := DepositAccount{}
	var err error
	if prehook, ok := interface{}(m).(DepositAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountID = m.PlaidAccountID
	to.AccountSubtype = m.AccountSubtype
	to.AccountType = m.AccountType
	to.AccountName = m.AccountName
	if m.BalanceID != nil {
		tempBalanceID, err := m.BalanceID.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.BalanceID = &tempBalanceID
	}
	if posthook, ok := interface{}(m).(DepositAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DepositAccount the arg will be the target, the caller the one being converted from

// DepositAccountBeforeToORM called before default ToORM code
type DepositAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *DepositAccountORM) error
}

// DepositAccountAfterToORM called after default ToORM code
type DepositAccountWithAfterToORM interface {
	AfterToORM(context.Context, *DepositAccountORM) error
}

// DepositAccountBeforeToPB called before default ToPB code
type DepositAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *DepositAccount) error
}

// DepositAccountAfterToPB called after default ToPB code
type DepositAccountWithAfterToPB interface {
	AfterToPB(context.Context, *DepositAccount) error
}

type CreditAccountORM struct {
	AccountName            string
	AccountSubtype         string
	AccountType            string
	Aprs                   []*APRORM   `gorm:"foreignkey:CreditAccountId;association_foreignkey:Id;preload:true"`
	BalanceID              *BalanceORM `gorm:"foreignkey:CreditAccountId;association_foreignkey:Id;preload:true"`
	Id                     uint64
	IsOverdue              bool
	LastPaymentAmount      float64
	LastPaymentDate        string
	LastStatementIssueDate string
	MinimumPaymentAmount   float64
	NextPaymentDueDate     string
	PlaidAccountID         string
	VirtualAccountId       *uint64
}

// TableName overrides the default tablename generated by GORM
func (CreditAccountORM) TableName() string {
	return "credit_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditAccount) ToORM(ctx context.Context) (CreditAccountORM, error) {
	to := CreditAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountID = m.PlaidAccountID
	to.AccountSubtype = m.AccountSubtype
	to.AccountType = m.AccountType
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	for _, v := range m.Aprs {
		if v != nil {
			if tempAprs, cErr := v.ToORM(ctx); cErr == nil {
				to.Aprs = append(to.Aprs, &tempAprs)
			} else {
				return to, cErr
			}
		} else {
			to.Aprs = append(to.Aprs, nil)
		}
	}
	if m.BalanceID != nil {
		tempBalanceID, err := m.BalanceID.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.BalanceID = &tempBalanceID
	}
	to.AccountName = m.AccountName
	if posthook, ok := interface{}(m).(CreditAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditAccountORM) ToPB(ctx context.Context) (CreditAccount, error) {
	to := CreditAccount{}
	var err error
	if prehook, ok := interface{}(m).(CreditAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountID = m.PlaidAccountID
	to.AccountSubtype = m.AccountSubtype
	to.AccountType = m.AccountType
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	for _, v := range m.Aprs {
		if v != nil {
			if tempAprs, cErr := v.ToPB(ctx); cErr == nil {
				to.Aprs = append(to.Aprs, &tempAprs)
			} else {
				return to, cErr
			}
		} else {
			to.Aprs = append(to.Aprs, nil)
		}
	}
	if m.BalanceID != nil {
		tempBalanceID, err := m.BalanceID.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.BalanceID = &tempBalanceID
	}
	to.AccountName = m.AccountName
	if posthook, ok := interface{}(m).(CreditAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditAccount the arg will be the target, the caller the one being converted from

// CreditAccountBeforeToORM called before default ToORM code
type CreditAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditAccountORM) error
}

// CreditAccountAfterToORM called after default ToORM code
type CreditAccountWithAfterToORM interface {
	AfterToORM(context.Context, *CreditAccountORM) error
}

// CreditAccountBeforeToPB called before default ToPB code
type CreditAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditAccount) error
}

// CreditAccountAfterToPB called after default ToPB code
type CreditAccountWithAfterToPB interface {
	AfterToPB(context.Context, *CreditAccount) error
}

type APRORM struct {
	APRPercentage        float64
	APRType              string
	BalanceSubjectToAPR  float64
	CreditAccountId      *uint64
	Id                   uint64
	InterestChargeAmount float64
}

// TableName overrides the default tablename generated by GORM
func (APRORM) TableName() string {
	return "aprs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *APR) ToORM(ctx context.Context) (APRORM, error) {
	to := APRORM{}
	var err error
	if prehook, ok := interface{}(m).(APRWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.APRPercentage = m.APRPercentage
	to.APRType = m.APRType
	to.BalanceSubjectToAPR = m.BalanceSubjectToAPR
	to.InterestChargeAmount = m.InterestChargeAmount
	if posthook, ok := interface{}(m).(APRWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *APRORM) ToPB(ctx context.Context) (APR, error) {
	to := APR{}
	var err error
	if prehook, ok := interface{}(m).(APRWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.APRPercentage = m.APRPercentage
	to.APRType = m.APRType
	to.BalanceSubjectToAPR = m.BalanceSubjectToAPR
	to.InterestChargeAmount = m.InterestChargeAmount
	if posthook, ok := interface{}(m).(APRWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type APR the arg will be the target, the caller the one being converted from

// APRBeforeToORM called before default ToORM code
type APRWithBeforeToORM interface {
	BeforeToORM(context.Context, *APRORM) error
}

// APRAfterToORM called after default ToORM code
type APRWithAfterToORM interface {
	AfterToORM(context.Context, *APRORM) error
}

// APRBeforeToPB called before default ToPB code
type APRWithBeforeToPB interface {
	BeforeToPB(context.Context, *APR) error
}

// APRAfterToPB called after default ToPB code
type APRWithAfterToPB interface {
	AfterToPB(context.Context, *APR) error
}

type MortgageLoanAccountORM struct {
	AccountName                string
	AccountNumber              string
	AccountSubtype             string
	AccountType                string
	AddressID                  *AddressORM `gorm:"foreignkey:MortgageLoanAccountId;association_foreignkey:Id;preload:true"`
	BalanceID                  *BalanceORM `gorm:"foreignkey:MortgageLoanAccountId;association_foreignkey:Id;preload:true"`
	CurrentLateFee             float64
	EscrowBalance              float64
	HasPmi                     bool
	HasPrepaymentPenalty       bool
	Id                         uint64
	InterestID                 *InterestORM `gorm:"foreignkey:MortgageLoanAccountId;association_foreignkey:Id;preload:true"`
	InterestPaidYTD            float64
	LastPaymentAmount          float64
	LastPaymentDate            string
	LoanTerm                   string
	LoanTypeDescription        string
	MaturityDate               string
	NexMonthlyPayment          float64
	NextPaymentDueDate         string
	OriginationDate            string
	OriginationPrincipalAmount float64
	PastDueAmount              float64
	PlaidAccountID             string
	PrincipalPaidYTD           float64
	VirtualAccountId           *uint64
}

// TableName overrides the default tablename generated by GORM
func (MortgageLoanAccountORM) TableName() string {
	return "mortgage_loan_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MortgageLoanAccount) ToORM(ctx context.Context) (MortgageLoanAccountORM, error) {
	to := MortgageLoanAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(MortgageLoanAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountID = m.PlaidAccountID
	to.AccountSubtype = m.AccountSubtype
	to.AccountType = m.AccountType
	to.AccountNumber = m.AccountNumber
	to.CurrentLateFee = m.CurrentLateFee
	to.EscrowBalance = m.EscrowBalance
	to.HasPmi = m.HasPmi
	to.HasPrepaymentPenalty = m.HasPrepaymentPenalty
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LoanTerm = m.LoanTerm
	to.LoanTypeDescription = m.LoanTypeDescription
	to.MaturityDate = m.MaturityDate
	to.NexMonthlyPayment = m.NexMonthlyPayment
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.PastDueAmount = m.PastDueAmount
	if m.InterestID != nil {
		tempInterestID, err := m.InterestID.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.InterestID = &tempInterestID
	}
	if m.AddressID != nil {
		tempAddressID, err := m.AddressID.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.AddressID = &tempAddressID
	}
	to.InterestPaidYTD = m.InterestPaidYTD
	to.PrincipalPaidYTD = m.PrincipalPaidYTD
	if m.BalanceID != nil {
		tempBalanceID, err := m.BalanceID.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.BalanceID = &tempBalanceID
	}
	to.AccountName = m.AccountName
	if posthook, ok := interface{}(m).(MortgageLoanAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MortgageLoanAccountORM) ToPB(ctx context.Context) (MortgageLoanAccount, error) {
	to := MortgageLoanAccount{}
	var err error
	if prehook, ok := interface{}(m).(MortgageLoanAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountID = m.PlaidAccountID
	to.AccountSubtype = m.AccountSubtype
	to.AccountType = m.AccountType
	to.AccountNumber = m.AccountNumber
	to.CurrentLateFee = m.CurrentLateFee
	to.EscrowBalance = m.EscrowBalance
	to.HasPmi = m.HasPmi
	to.HasPrepaymentPenalty = m.HasPrepaymentPenalty
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LoanTerm = m.LoanTerm
	to.LoanTypeDescription = m.LoanTypeDescription
	to.MaturityDate = m.MaturityDate
	to.NexMonthlyPayment = m.NexMonthlyPayment
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.PastDueAmount = m.PastDueAmount
	if m.InterestID != nil {
		tempInterestID, err := m.InterestID.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.InterestID = &tempInterestID
	}
	if m.AddressID != nil {
		tempAddressID, err := m.AddressID.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.AddressID = &tempAddressID
	}
	to.InterestPaidYTD = m.InterestPaidYTD
	to.PrincipalPaidYTD = m.PrincipalPaidYTD
	if m.BalanceID != nil {
		tempBalanceID, err := m.BalanceID.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.BalanceID = &tempBalanceID
	}
	to.AccountName = m.AccountName
	if posthook, ok := interface{}(m).(MortgageLoanAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MortgageLoanAccount the arg will be the target, the caller the one being converted from

// MortgageLoanAccountBeforeToORM called before default ToORM code
type MortgageLoanAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *MortgageLoanAccountORM) error
}

// MortgageLoanAccountAfterToORM called after default ToORM code
type MortgageLoanAccountWithAfterToORM interface {
	AfterToORM(context.Context, *MortgageLoanAccountORM) error
}

// MortgageLoanAccountBeforeToPB called before default ToPB code
type MortgageLoanAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *MortgageLoanAccount) error
}

// MortgageLoanAccountAfterToPB called after default ToPB code
type MortgageLoanAccountWithAfterToPB interface {
	AfterToPB(context.Context, *MortgageLoanAccount) error
}

type InterestORM struct {
	Id                    uint64
	MortgageLoanAccountId *uint64
	Percentage            float64
	Type                  string
}

// TableName overrides the default tablename generated by GORM
func (InterestORM) TableName() string {
	return "interests"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Interest) ToORM(ctx context.Context) (InterestORM, error) {
	to := InterestORM{}
	var err error
	if prehook, ok := interface{}(m).(InterestWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Percentage = m.Percentage
	to.Type = m.Type
	if posthook, ok := interface{}(m).(InterestWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InterestORM) ToPB(ctx context.Context) (Interest, error) {
	to := Interest{}
	var err error
	if prehook, ok := interface{}(m).(InterestWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Percentage = m.Percentage
	to.Type = m.Type
	if posthook, ok := interface{}(m).(InterestWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Interest the arg will be the target, the caller the one being converted from

// InterestBeforeToORM called before default ToORM code
type InterestWithBeforeToORM interface {
	BeforeToORM(context.Context, *InterestORM) error
}

// InterestAfterToORM called after default ToORM code
type InterestWithAfterToORM interface {
	AfterToORM(context.Context, *InterestORM) error
}

// InterestBeforeToPB called before default ToPB code
type InterestWithBeforeToPB interface {
	BeforeToPB(context.Context, *Interest) error
}

// InterestAfterToPB called after default ToPB code
type InterestWithAfterToPB interface {
	AfterToPB(context.Context, *Interest) error
}

type AddressORM struct {
	City                  string
	Country               string
	Id                    uint64
	MortgageLoanAccountId *uint64
	Region                string
	Street                string
	StudentLoanAccountId  *uint64
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.City = m.City
	to.Country = m.Country
	to.Region = m.Region
	to.Street = m.Street
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.City = m.City
	to.Country = m.Country
	to.Region = m.Region
	to.Street = m.Street
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type StudentLoanAccountORM struct {
	AccountName                string
	AccountNumber              string
	AccountSubtype             string
	AccountType                string
	BalanceID                  *BalanceORM    `gorm:"foreignkey:StudentLoanAccountId;association_foreignkey:Id;preload:true"`
	DisbursementDates          pq.StringArray `gorm:"type:text[]"`
	ExpectedPayoffDate         string
	Guarantor                  string
	Id                         uint64
	InterestPaidYTD            float64
	InterestRatePercentage     float64
	IsOverdue                  bool
	LastPaymentAmount          float64
	LastPaymentDate            string
	LastStatementIssueDate     string
	LoanName                   string
	LoanRepaymentEndDate       string
	LoanStatementIssueDate     string
	MinimumPaymentAmount       float64
	NextPaymentDueDate         string
	OriginationDate            string
	OriginationPrincipalAmount float64
	OutstandingInterestAmount  float64
	PaymentReferenceNumber     string
	PlaidAccountID             string
	PrincipalPaidYTD           float64
	PslfID                     *PslfORM `gorm:"foreignkey:StudentLoanAccountId;association_foreignkey:Id;preload:true"`
	RepaymentPlan              string
	SequenceNumber             string
	ServisorAddressID          *AddressORM `gorm:"foreignkey:StudentLoanAccountId;association_foreignkey:Id;preload:true"`
	VirtualAccountId           *uint64
}

// TableName overrides the default tablename generated by GORM
func (StudentLoanAccountORM) TableName() string {
	return "student_loan_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *StudentLoanAccount) ToORM(ctx context.Context) (StudentLoanAccountORM, error) {
	to := StudentLoanAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(StudentLoanAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountID = m.PlaidAccountID
	to.AccountSubtype = m.AccountSubtype
	to.AccountType = m.AccountType
	to.AccountNumber = m.AccountNumber
	if m.DisbursementDates != nil {
		to.DisbursementDates = make(pq.StringArray, len(m.DisbursementDates))
		copy(to.DisbursementDates, m.DisbursementDates)
	}
	to.ExpectedPayoffDate = m.ExpectedPayoffDate
	to.Guarantor = m.Guarantor
	to.InterestRatePercentage = m.InterestRatePercentage
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.LoanStatementIssueDate = m.LoanStatementIssueDate
	to.LoanName = m.LoanName
	to.LoanRepaymentEndDate = m.LoanRepaymentEndDate
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.OutstandingInterestAmount = m.OutstandingInterestAmount
	to.PaymentReferenceNumber = m.PaymentReferenceNumber
	to.SequenceNumber = m.SequenceNumber
	if m.PslfID != nil {
		tempPslfID, err := m.PslfID.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PslfID = &tempPslfID
	}
	to.RepaymentPlan = m.RepaymentPlan
	if m.ServisorAddressID != nil {
		tempServisorAddressID, err := m.ServisorAddressID.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ServisorAddressID = &tempServisorAddressID
	}
	to.InterestPaidYTD = m.InterestPaidYTD
	to.PrincipalPaidYTD = m.PrincipalPaidYTD
	if m.BalanceID != nil {
		tempBalanceID, err := m.BalanceID.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.BalanceID = &tempBalanceID
	}
	to.AccountName = m.AccountName
	if posthook, ok := interface{}(m).(StudentLoanAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StudentLoanAccountORM) ToPB(ctx context.Context) (StudentLoanAccount, error) {
	to := StudentLoanAccount{}
	var err error
	if prehook, ok := interface{}(m).(StudentLoanAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountID = m.PlaidAccountID
	to.AccountSubtype = m.AccountSubtype
	to.AccountType = m.AccountType
	to.AccountNumber = m.AccountNumber
	if m.DisbursementDates != nil {
		to.DisbursementDates = make(pq.StringArray, len(m.DisbursementDates))
		copy(to.DisbursementDates, m.DisbursementDates)
	}
	to.ExpectedPayoffDate = m.ExpectedPayoffDate
	to.Guarantor = m.Guarantor
	to.InterestRatePercentage = m.InterestRatePercentage
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.LoanStatementIssueDate = m.LoanStatementIssueDate
	to.LoanName = m.LoanName
	to.LoanRepaymentEndDate = m.LoanRepaymentEndDate
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.OutstandingInterestAmount = m.OutstandingInterestAmount
	to.PaymentReferenceNumber = m.PaymentReferenceNumber
	to.SequenceNumber = m.SequenceNumber
	if m.PslfID != nil {
		tempPslfID, err := m.PslfID.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PslfID = &tempPslfID
	}
	to.RepaymentPlan = m.RepaymentPlan
	if m.ServisorAddressID != nil {
		tempServisorAddressID, err := m.ServisorAddressID.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ServisorAddressID = &tempServisorAddressID
	}
	to.InterestPaidYTD = m.InterestPaidYTD
	to.PrincipalPaidYTD = m.PrincipalPaidYTD
	if m.BalanceID != nil {
		tempBalanceID, err := m.BalanceID.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.BalanceID = &tempBalanceID
	}
	to.AccountName = m.AccountName
	if posthook, ok := interface{}(m).(StudentLoanAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type StudentLoanAccount the arg will be the target, the caller the one being converted from

// StudentLoanAccountBeforeToORM called before default ToORM code
type StudentLoanAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *StudentLoanAccountORM) error
}

// StudentLoanAccountAfterToORM called after default ToORM code
type StudentLoanAccountWithAfterToORM interface {
	AfterToORM(context.Context, *StudentLoanAccountORM) error
}

// StudentLoanAccountBeforeToPB called before default ToPB code
type StudentLoanAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *StudentLoanAccount) error
}

// StudentLoanAccountAfterToPB called after default ToPB code
type StudentLoanAccountWithAfterToPB interface {
	AfterToPB(context.Context, *StudentLoanAccount) error
}

type PslfORM struct {
	EstimatedEligibilityDate string
	Id                       uint64
	PaymentsMade             uint64
	PaymentsRemaining        uint64
	StudentLoanAccountId     *uint64
}

// TableName overrides the default tablename generated by GORM
func (PslfORM) TableName() string {
	return "pslves"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Pslf) ToORM(ctx context.Context) (PslfORM, error) {
	to := PslfORM{}
	var err error
	if prehook, ok := interface{}(m).(PslfWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.EstimatedEligibilityDate = m.EstimatedEligibilityDate
	to.PaymentsMade = m.PaymentsMade
	to.PaymentsRemaining = m.PaymentsRemaining
	if posthook, ok := interface{}(m).(PslfWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PslfORM) ToPB(ctx context.Context) (Pslf, error) {
	to := Pslf{}
	var err error
	if prehook, ok := interface{}(m).(PslfWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.EstimatedEligibilityDate = m.EstimatedEligibilityDate
	to.PaymentsMade = m.PaymentsMade
	to.PaymentsRemaining = m.PaymentsRemaining
	if posthook, ok := interface{}(m).(PslfWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Pslf the arg will be the target, the caller the one being converted from

// PslfBeforeToORM called before default ToORM code
type PslfWithBeforeToORM interface {
	BeforeToORM(context.Context, *PslfORM) error
}

// PslfAfterToORM called after default ToORM code
type PslfWithAfterToORM interface {
	AfterToORM(context.Context, *PslfORM) error
}

// PslfBeforeToPB called before default ToPB code
type PslfWithBeforeToPB interface {
	BeforeToPB(context.Context, *Pslf) error
}

// PslfAfterToPB called after default ToPB code
type PslfWithAfterToPB interface {
	AfterToPB(context.Context, *Pslf) error
}

type InvestmentAccountORM struct {
	AccountName      string
	AccountSubtype   string
	AccountType      string
	BalanceID        *BalanceORM `gorm:"foreignkey:InvestmentAccountId;association_foreignkey:Id;preload:true"`
	Id               uint64
	PlaidAccountID   string
	SecurityID       []*SecurityORM `gorm:"foreignkey:InvestmentAccountId;association_foreignkey:Id;preload:true"`
	VirtualAccountId *uint64
}

// TableName overrides the default tablename generated by GORM
func (InvestmentAccountORM) TableName() string {
	return "investment_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvestmentAccount) ToORM(ctx context.Context) (InvestmentAccountORM, error) {
	to := InvestmentAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountID = m.PlaidAccountID
	to.AccountSubtype = m.AccountSubtype
	to.AccountType = m.AccountType
	to.AccountName = m.AccountName
	if m.BalanceID != nil {
		tempBalanceID, err := m.BalanceID.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.BalanceID = &tempBalanceID
	}
	for _, v := range m.SecurityID {
		if v != nil {
			if tempSecurityID, cErr := v.ToORM(ctx); cErr == nil {
				to.SecurityID = append(to.SecurityID, &tempSecurityID)
			} else {
				return to, cErr
			}
		} else {
			to.SecurityID = append(to.SecurityID, nil)
		}
	}
	if posthook, ok := interface{}(m).(InvestmentAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestmentAccountORM) ToPB(ctx context.Context) (InvestmentAccount, error) {
	to := InvestmentAccount{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountID = m.PlaidAccountID
	to.AccountSubtype = m.AccountSubtype
	to.AccountType = m.AccountType
	to.AccountName = m.AccountName
	if m.BalanceID != nil {
		tempBalanceID, err := m.BalanceID.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.BalanceID = &tempBalanceID
	}
	for _, v := range m.SecurityID {
		if v != nil {
			if tempSecurityID, cErr := v.ToPB(ctx); cErr == nil {
				to.SecurityID = append(to.SecurityID, &tempSecurityID)
			} else {
				return to, cErr
			}
		} else {
			to.SecurityID = append(to.SecurityID, nil)
		}
	}
	if posthook, ok := interface{}(m).(InvestmentAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvestmentAccount the arg will be the target, the caller the one being converted from

// InvestmentAccountBeforeToORM called before default ToORM code
type InvestmentAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestmentAccountORM) error
}

// InvestmentAccountAfterToORM called after default ToORM code
type InvestmentAccountWithAfterToORM interface {
	AfterToORM(context.Context, *InvestmentAccountORM) error
}

// InvestmentAccountBeforeToPB called before default ToPB code
type InvestmentAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvestmentAccount) error
}

// InvestmentAccountAfterToPB called after default ToPB code
type InvestmentAccountWithAfterToPB interface {
	AfterToPB(context.Context, *InvestmentAccount) error
}

// DefaultCreateSecurity executes a basic gorm create call
func DefaultCreateSecurity(ctx context.Context, in *Security, db *gorm.DB) (*Security, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SecurityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SecurityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSecurity(ctx context.Context, in *Security, db *gorm.DB) (*Security, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &SecurityORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SecurityORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SecurityORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SecurityORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SecurityORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SecurityORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSecurity(ctx context.Context, in *Security, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SecurityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SecurityORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SecurityORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSecuritySet(ctx context.Context, in []*Security, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SecurityORM{})).(SecurityORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SecurityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SecurityORM{})).(SecurityORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SecurityORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Security, *gorm.DB) (*gorm.DB, error)
}
type SecurityORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Security, *gorm.DB) error
}

// DefaultStrictUpdateSecurity clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSecurity(ctx context.Context, in *Security, db *gorm.DB) (*Security, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSecurity")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SecurityORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SecurityORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SecurityORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SecurityORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SecurityORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSecurity executes a basic gorm update call with patch behavior
func DefaultPatchSecurity(ctx context.Context, in *Security, updateMask *field_mask.FieldMask, db *gorm.DB) (*Security, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Security
	var err error
	if hook, ok := interface{}(&pbObj).(SecurityWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSecurity(ctx, &Security{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SecurityWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSecurity(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SecurityWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSecurity(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SecurityWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SecurityWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Security, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SecurityWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Security, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SecurityWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Security, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SecurityWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Security, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSecurity executes a bulk gorm update call with patch behavior
func DefaultPatchSetSecurity(ctx context.Context, objects []*Security, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Security, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Security, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSecurity(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSecurity patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSecurity(ctx context.Context, patchee *Security, patcher *Security, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Security, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"IsCashEquivalent" {
			patchee.IsCashEquivalent = patcher.IsCashEquivalent
			continue
		}
		if f == prefix+"ClosePrice" {
			patchee.ClosePrice = patcher.ClosePrice
			continue
		}
		if f == prefix+"CurrencyCode" {
			patchee.CurrencyCode = patcher.CurrencyCode
			continue
		}
		if f == prefix+"SecurityID" {
			patchee.SecurityID = patcher.SecurityID
			continue
		}
		if f == prefix+"TickerSymbol" {
			patchee.TickerSymbol = patcher.TickerSymbol
			continue
		}
		if f == prefix+"SecurityType" {
			patchee.SecurityType = patcher.SecurityType
			continue
		}
		if f == prefix+"SecurityName" {
			patchee.SecurityName = patcher.SecurityName
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSecurity executes a gorm list call
func DefaultListSecurity(ctx context.Context, db *gorm.DB) ([]*Security, error) {
	in := Security{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SecurityORM{}, &Security{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SecurityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecurityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Security{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SecurityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SecurityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SecurityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SecurityORM) error
}

// DefaultCreateBalance executes a basic gorm create call
func DefaultCreateBalance(ctx context.Context, in *Balance, db *gorm.DB) (*Balance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BalanceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBalance(ctx context.Context, in *Balance, db *gorm.DB) (*Balance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BalanceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BalanceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BalanceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BalanceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBalance(ctx context.Context, in *Balance, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BalanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BalanceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBalanceSet(ctx context.Context, in []*Balance, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BalanceORM{})).(BalanceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BalanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BalanceORM{})).(BalanceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BalanceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Balance, *gorm.DB) (*gorm.DB, error)
}
type BalanceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Balance, *gorm.DB) error
}

// DefaultStrictUpdateBalance clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBalance(ctx context.Context, in *Balance, db *gorm.DB) (*Balance, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBalance")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BalanceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BalanceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BalanceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBalance executes a basic gorm update call with patch behavior
func DefaultPatchBalance(ctx context.Context, in *Balance, updateMask *field_mask.FieldMask, db *gorm.DB) (*Balance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Balance
	var err error
	if hook, ok := interface{}(&pbObj).(BalanceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBalance(ctx, &Balance{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BalanceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBalance(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BalanceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBalance(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BalanceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BalanceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Balance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Balance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Balance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Balance, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBalance executes a bulk gorm update call with patch behavior
func DefaultPatchSetBalance(ctx context.Context, objects []*Balance, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Balance, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Balance, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBalance(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBalance patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBalance(ctx context.Context, patchee *Balance, patcher *Balance, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Balance, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AvailableFunds" {
			patchee.AvailableFunds = patcher.AvailableFunds
			continue
		}
		if f == prefix+"CurrentFunds" {
			patchee.CurrentFunds = patcher.CurrentFunds
			continue
		}
		if f == prefix+"CurrencyCode" {
			patchee.CurrencyCode = patcher.CurrencyCode
			continue
		}
		if f == prefix+"BalanceLimit" {
			patchee.BalanceLimit = patcher.BalanceLimit
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBalance executes a gorm list call
func DefaultListBalance(ctx context.Context, db *gorm.DB) ([]*Balance, error) {
	in := Balance{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BalanceORM{}, &Balance{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BalanceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Balance{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BalanceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BalanceORM) error
}

// DefaultCreateVirtualAccount executes a basic gorm create call
func DefaultCreateVirtualAccount(ctx context.Context, in *VirtualAccount, db *gorm.DB) (*VirtualAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VirtualAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadVirtualAccount(ctx context.Context, in *VirtualAccount, db *gorm.DB) (*VirtualAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &VirtualAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := VirtualAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VirtualAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VirtualAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteVirtualAccount(ctx context.Context, in *VirtualAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VirtualAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type VirtualAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteVirtualAccountSet(ctx context.Context, in []*VirtualAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&VirtualAccountORM{})).(VirtualAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&VirtualAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&VirtualAccountORM{})).(VirtualAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type VirtualAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*VirtualAccount, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*VirtualAccount, *gorm.DB) error
}

// DefaultStrictUpdateVirtualAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVirtualAccount(ctx context.Context, in *VirtualAccount, db *gorm.DB) (*VirtualAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVirtualAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &VirtualAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCreditAccountID := CreditAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCreditAccountID.VirtualAccountId = new(uint64)
	*filterCreditAccountID.VirtualAccountId = ormObj.Id
	if err = db.Where(filterCreditAccountID).Delete(CreditAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterDepositAccountID := DepositAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterDepositAccountID.VirtualAccountId = new(uint64)
	*filterDepositAccountID.VirtualAccountId = ormObj.Id
	if err = db.Where(filterDepositAccountID).Delete(DepositAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterInvestmentAccountID := InvestmentAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInvestmentAccountID.VirtualAccountId = new(uint64)
	*filterInvestmentAccountID.VirtualAccountId = ormObj.Id
	if err = db.Where(filterInvestmentAccountID).Delete(InvestmentAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterMortgageLoanAccountID := MortgageLoanAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterMortgageLoanAccountID.VirtualAccountId = new(uint64)
	*filterMortgageLoanAccountID.VirtualAccountId = ormObj.Id
	if err = db.Where(filterMortgageLoanAccountID).Delete(MortgageLoanAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterStudentLoanAccountID := StudentLoanAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterStudentLoanAccountID.VirtualAccountId = new(uint64)
	*filterStudentLoanAccountID.VirtualAccountId = ormObj.Id
	if err = db.Where(filterStudentLoanAccountID).Delete(StudentLoanAccountORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type VirtualAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchVirtualAccount executes a basic gorm update call with patch behavior
func DefaultPatchVirtualAccount(ctx context.Context, in *VirtualAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*VirtualAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj VirtualAccount
	var err error
	if hook, ok := interface{}(&pbObj).(VirtualAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVirtualAccount(ctx, &VirtualAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VirtualAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVirtualAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VirtualAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVirtualAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VirtualAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VirtualAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *VirtualAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *VirtualAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *VirtualAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *VirtualAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetVirtualAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetVirtualAccount(ctx context.Context, objects []*VirtualAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*VirtualAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*VirtualAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchVirtualAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskVirtualAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVirtualAccount(ctx context.Context, patchee *VirtualAccount, patcher *VirtualAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*VirtualAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AccessToken" {
			patchee.AccessToken = patcher.AccessToken
			continue
		}
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"DepositAccountID" {
			patchee.DepositAccountID = patcher.DepositAccountID
			continue
		}
		if f == prefix+"CreditAccountID" {
			patchee.CreditAccountID = patcher.CreditAccountID
			continue
		}
		if f == prefix+"MortgageLoanAccountID" {
			patchee.MortgageLoanAccountID = patcher.MortgageLoanAccountID
			continue
		}
		if f == prefix+"StudentLoanAccountID" {
			patchee.StudentLoanAccountID = patcher.StudentLoanAccountID
			continue
		}
		if f == prefix+"InvestmentAccountID" {
			patchee.InvestmentAccountID = patcher.InvestmentAccountID
			continue
		}
		if f == prefix+"Active" {
			patchee.Active = patcher.Active
			continue
		}
		if f == prefix+"PlaidItemID" {
			patchee.PlaidItemID = patcher.PlaidItemID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVirtualAccount executes a gorm list call
func DefaultListVirtualAccount(ctx context.Context, db *gorm.DB) ([]*VirtualAccount, error) {
	in := VirtualAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &VirtualAccountORM{}, &VirtualAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VirtualAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*VirtualAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VirtualAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]VirtualAccountORM) error
}

// DefaultCreateDepositAccount executes a basic gorm create call
func DefaultCreateDepositAccount(ctx context.Context, in *DepositAccount, db *gorm.DB) (*DepositAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DepositAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDepositAccount(ctx context.Context, in *DepositAccount, db *gorm.DB) (*DepositAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &DepositAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DepositAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DepositAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DepositAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDepositAccount(ctx context.Context, in *DepositAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DepositAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DepositAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDepositAccountSet(ctx context.Context, in []*DepositAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DepositAccountORM{})).(DepositAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DepositAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DepositAccountORM{})).(DepositAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DepositAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DepositAccount, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DepositAccount, *gorm.DB) error
}

// DefaultStrictUpdateDepositAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDepositAccount(ctx context.Context, in *DepositAccount, db *gorm.DB) (*DepositAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDepositAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DepositAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBalanceID := BalanceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBalanceID.DepositAccountId = new(uint64)
	*filterBalanceID.DepositAccountId = ormObj.Id
	if err = db.Where(filterBalanceID).Delete(BalanceORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DepositAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDepositAccount executes a basic gorm update call with patch behavior
func DefaultPatchDepositAccount(ctx context.Context, in *DepositAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*DepositAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DepositAccount
	var err error
	if hook, ok := interface{}(&pbObj).(DepositAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDepositAccount(ctx, &DepositAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DepositAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDepositAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DepositAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDepositAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DepositAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DepositAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DepositAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DepositAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DepositAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DepositAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDepositAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetDepositAccount(ctx context.Context, objects []*DepositAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DepositAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DepositAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDepositAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDepositAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDepositAccount(ctx context.Context, patchee *DepositAccount, patcher *DepositAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DepositAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedBalanceID bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PlaidAccountID" {
			patchee.PlaidAccountID = patcher.PlaidAccountID
			continue
		}
		if f == prefix+"AccountSubtype" {
			patchee.AccountSubtype = patcher.AccountSubtype
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"AccountName" {
			patchee.AccountName = patcher.AccountName
			continue
		}
		if !updatedBalanceID && strings.HasPrefix(f, prefix+"BalanceID.") {
			updatedBalanceID = true
			if patcher.BalanceID == nil {
				patchee.BalanceID = nil
				continue
			}
			if patchee.BalanceID == nil {
				patchee.BalanceID = &Balance{}
			}
			if o, err := DefaultApplyFieldMaskBalance(ctx, patchee.BalanceID, patcher.BalanceID, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"BalanceID.", db); err != nil {
				return nil, err
			} else {
				patchee.BalanceID = o
			}
			continue
		}
		if f == prefix+"BalanceID" {
			updatedBalanceID = true
			patchee.BalanceID = patcher.BalanceID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDepositAccount executes a gorm list call
func DefaultListDepositAccount(ctx context.Context, db *gorm.DB) ([]*DepositAccount, error) {
	in := DepositAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &DepositAccountORM{}, &DepositAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DepositAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepositAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DepositAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DepositAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepositAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DepositAccountORM) error
}

// DefaultCreateCreditAccount executes a basic gorm create call
func DefaultCreateCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreditAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditAccountSet(ctx context.Context, in []*CreditAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditAccountORM{})).(CreditAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreditAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreditAccountORM{})).(CreditAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditAccount, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditAccount, *gorm.DB) error
}

// DefaultStrictUpdateCreditAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreditAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAprs := APRORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAprs.CreditAccountId = new(uint64)
	*filterAprs.CreditAccountId = ormObj.Id
	if err = db.Where(filterAprs).Delete(APRORM{}).Error; err != nil {
		return nil, err
	}
	filterBalanceID := BalanceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBalanceID.CreditAccountId = new(uint64)
	*filterBalanceID.CreditAccountId = ormObj.Id
	if err = db.Where(filterBalanceID).Delete(BalanceORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreditAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreditAccount executes a basic gorm update call with patch behavior
func DefaultPatchCreditAccount(ctx context.Context, in *CreditAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreditAccount
	var err error
	if hook, ok := interface{}(&pbObj).(CreditAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditAccount(ctx, &CreditAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreditAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditAccount(ctx context.Context, objects []*CreditAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreditAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditAccount(ctx context.Context, patchee *CreditAccount, patcher *CreditAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreditAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedBalanceID bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PlaidAccountID" {
			patchee.PlaidAccountID = patcher.PlaidAccountID
			continue
		}
		if f == prefix+"AccountSubtype" {
			patchee.AccountSubtype = patcher.AccountSubtype
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"IsOverdue" {
			patchee.IsOverdue = patcher.IsOverdue
			continue
		}
		if f == prefix+"LastPaymentAmount" {
			patchee.LastPaymentAmount = patcher.LastPaymentAmount
			continue
		}
		if f == prefix+"LastPaymentDate" {
			patchee.LastPaymentDate = patcher.LastPaymentDate
			continue
		}
		if f == prefix+"LastStatementIssueDate" {
			patchee.LastStatementIssueDate = patcher.LastStatementIssueDate
			continue
		}
		if f == prefix+"MinimumPaymentAmount" {
			patchee.MinimumPaymentAmount = patcher.MinimumPaymentAmount
			continue
		}
		if f == prefix+"NextPaymentDueDate" {
			patchee.NextPaymentDueDate = patcher.NextPaymentDueDate
			continue
		}
		if f == prefix+"Aprs" {
			patchee.Aprs = patcher.Aprs
			continue
		}
		if !updatedBalanceID && strings.HasPrefix(f, prefix+"BalanceID.") {
			updatedBalanceID = true
			if patcher.BalanceID == nil {
				patchee.BalanceID = nil
				continue
			}
			if patchee.BalanceID == nil {
				patchee.BalanceID = &Balance{}
			}
			if o, err := DefaultApplyFieldMaskBalance(ctx, patchee.BalanceID, patcher.BalanceID, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"BalanceID.", db); err != nil {
				return nil, err
			} else {
				patchee.BalanceID = o
			}
			continue
		}
		if f == prefix+"BalanceID" {
			updatedBalanceID = true
			patchee.BalanceID = patcher.BalanceID
			continue
		}
		if f == prefix+"AccountName" {
			patchee.AccountName = patcher.AccountName
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditAccount executes a gorm list call
func DefaultListCreditAccount(ctx context.Context, db *gorm.DB) ([]*CreditAccount, error) {
	in := CreditAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreditAccountORM{}, &CreditAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreditAccountORM) error
}

// DefaultCreateAPR executes a basic gorm create call
func DefaultCreateAPR(ctx context.Context, in *APR, db *gorm.DB) (*APR, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type APRORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APRORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAPR(ctx context.Context, in *APR, db *gorm.DB) (*APR, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &APRORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := APRORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(APRORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type APRORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APRORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APRORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAPR(ctx context.Context, in *APR, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&APRORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type APRORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APRORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAPRSet(ctx context.Context, in []*APR, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&APRORM{})).(APRORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&APRORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&APRORM{})).(APRORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type APRORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*APR, *gorm.DB) (*gorm.DB, error)
}
type APRORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*APR, *gorm.DB) error
}

// DefaultStrictUpdateAPR clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAPR(ctx context.Context, in *APR, db *gorm.DB) (*APR, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAPR")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &APRORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(APRORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type APRORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APRORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APRORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAPR executes a basic gorm update call with patch behavior
func DefaultPatchAPR(ctx context.Context, in *APR, updateMask *field_mask.FieldMask, db *gorm.DB) (*APR, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj APR
	var err error
	if hook, ok := interface{}(&pbObj).(APRWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAPR(ctx, &APR{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(APRWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAPR(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(APRWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAPR(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(APRWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type APRWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *APR, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type APRWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *APR, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type APRWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *APR, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type APRWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *APR, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAPR executes a bulk gorm update call with patch behavior
func DefaultPatchSetAPR(ctx context.Context, objects []*APR, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*APR, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*APR, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAPR(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAPR patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAPR(ctx context.Context, patchee *APR, patcher *APR, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*APR, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"APRPercentage" {
			patchee.APRPercentage = patcher.APRPercentage
			continue
		}
		if f == prefix+"APRType" {
			patchee.APRType = patcher.APRType
			continue
		}
		if f == prefix+"BalanceSubjectToAPR" {
			patchee.BalanceSubjectToAPR = patcher.BalanceSubjectToAPR
			continue
		}
		if f == prefix+"InterestChargeAmount" {
			patchee.InterestChargeAmount = patcher.InterestChargeAmount
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAPR executes a gorm list call
func DefaultListAPR(ctx context.Context, db *gorm.DB) ([]*APR, error) {
	in := APR{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &APRORM{}, &APR{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []APRORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(APRORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*APR{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type APRORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APRORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type APRORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]APRORM) error
}

// DefaultCreateMortgageLoanAccount executes a basic gorm create call
func DefaultCreateMortgageLoanAccount(ctx context.Context, in *MortgageLoanAccount, db *gorm.DB) (*MortgageLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MortgageLoanAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMortgageLoanAccount(ctx context.Context, in *MortgageLoanAccount, db *gorm.DB) (*MortgageLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MortgageLoanAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MortgageLoanAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MortgageLoanAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MortgageLoanAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMortgageLoanAccount(ctx context.Context, in *MortgageLoanAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MortgageLoanAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MortgageLoanAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMortgageLoanAccountSet(ctx context.Context, in []*MortgageLoanAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MortgageLoanAccountORM{})).(MortgageLoanAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MortgageLoanAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MortgageLoanAccountORM{})).(MortgageLoanAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MortgageLoanAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MortgageLoanAccount, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MortgageLoanAccount, *gorm.DB) error
}

// DefaultStrictUpdateMortgageLoanAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMortgageLoanAccount(ctx context.Context, in *MortgageLoanAccount, db *gorm.DB) (*MortgageLoanAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMortgageLoanAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MortgageLoanAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddressID := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddressID.MortgageLoanAccountId = new(uint64)
	*filterAddressID.MortgageLoanAccountId = ormObj.Id
	if err = db.Where(filterAddressID).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterBalanceID := BalanceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBalanceID.MortgageLoanAccountId = new(uint64)
	*filterBalanceID.MortgageLoanAccountId = ormObj.Id
	if err = db.Where(filterBalanceID).Delete(BalanceORM{}).Error; err != nil {
		return nil, err
	}
	filterInterestID := InterestORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInterestID.MortgageLoanAccountId = new(uint64)
	*filterInterestID.MortgageLoanAccountId = ormObj.Id
	if err = db.Where(filterInterestID).Delete(InterestORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MortgageLoanAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMortgageLoanAccount executes a basic gorm update call with patch behavior
func DefaultPatchMortgageLoanAccount(ctx context.Context, in *MortgageLoanAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*MortgageLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MortgageLoanAccount
	var err error
	if hook, ok := interface{}(&pbObj).(MortgageLoanAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMortgageLoanAccount(ctx, &MortgageLoanAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MortgageLoanAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMortgageLoanAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MortgageLoanAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMortgageLoanAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MortgageLoanAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MortgageLoanAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MortgageLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MortgageLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MortgageLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MortgageLoanAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMortgageLoanAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetMortgageLoanAccount(ctx context.Context, objects []*MortgageLoanAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MortgageLoanAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MortgageLoanAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMortgageLoanAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMortgageLoanAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMortgageLoanAccount(ctx context.Context, patchee *MortgageLoanAccount, patcher *MortgageLoanAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MortgageLoanAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedInterestID bool
	var updatedAddressID bool
	var updatedBalanceID bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PlaidAccountID" {
			patchee.PlaidAccountID = patcher.PlaidAccountID
			continue
		}
		if f == prefix+"AccountSubtype" {
			patchee.AccountSubtype = patcher.AccountSubtype
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"CurrentLateFee" {
			patchee.CurrentLateFee = patcher.CurrentLateFee
			continue
		}
		if f == prefix+"EscrowBalance" {
			patchee.EscrowBalance = patcher.EscrowBalance
			continue
		}
		if f == prefix+"HasPmi" {
			patchee.HasPmi = patcher.HasPmi
			continue
		}
		if f == prefix+"HasPrepaymentPenalty" {
			patchee.HasPrepaymentPenalty = patcher.HasPrepaymentPenalty
			continue
		}
		if f == prefix+"LastPaymentAmount" {
			patchee.LastPaymentAmount = patcher.LastPaymentAmount
			continue
		}
		if f == prefix+"LastPaymentDate" {
			patchee.LastPaymentDate = patcher.LastPaymentDate
			continue
		}
		if f == prefix+"LoanTerm" {
			patchee.LoanTerm = patcher.LoanTerm
			continue
		}
		if f == prefix+"LoanTypeDescription" {
			patchee.LoanTypeDescription = patcher.LoanTypeDescription
			continue
		}
		if f == prefix+"MaturityDate" {
			patchee.MaturityDate = patcher.MaturityDate
			continue
		}
		if f == prefix+"NexMonthlyPayment" {
			patchee.NexMonthlyPayment = patcher.NexMonthlyPayment
			continue
		}
		if f == prefix+"NextPaymentDueDate" {
			patchee.NextPaymentDueDate = patcher.NextPaymentDueDate
			continue
		}
		if f == prefix+"OriginationDate" {
			patchee.OriginationDate = patcher.OriginationDate
			continue
		}
		if f == prefix+"OriginationPrincipalAmount" {
			patchee.OriginationPrincipalAmount = patcher.OriginationPrincipalAmount
			continue
		}
		if f == prefix+"PastDueAmount" {
			patchee.PastDueAmount = patcher.PastDueAmount
			continue
		}
		if !updatedInterestID && strings.HasPrefix(f, prefix+"InterestID.") {
			updatedInterestID = true
			if patcher.InterestID == nil {
				patchee.InterestID = nil
				continue
			}
			if patchee.InterestID == nil {
				patchee.InterestID = &Interest{}
			}
			if o, err := DefaultApplyFieldMaskInterest(ctx, patchee.InterestID, patcher.InterestID, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"InterestID.", db); err != nil {
				return nil, err
			} else {
				patchee.InterestID = o
			}
			continue
		}
		if f == prefix+"InterestID" {
			updatedInterestID = true
			patchee.InterestID = patcher.InterestID
			continue
		}
		if !updatedAddressID && strings.HasPrefix(f, prefix+"AddressID.") {
			updatedAddressID = true
			if patcher.AddressID == nil {
				patchee.AddressID = nil
				continue
			}
			if patchee.AddressID == nil {
				patchee.AddressID = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.AddressID, patcher.AddressID, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"AddressID.", db); err != nil {
				return nil, err
			} else {
				patchee.AddressID = o
			}
			continue
		}
		if f == prefix+"AddressID" {
			updatedAddressID = true
			patchee.AddressID = patcher.AddressID
			continue
		}
		if f == prefix+"InterestPaidYTD" {
			patchee.InterestPaidYTD = patcher.InterestPaidYTD
			continue
		}
		if f == prefix+"PrincipalPaidYTD" {
			patchee.PrincipalPaidYTD = patcher.PrincipalPaidYTD
			continue
		}
		if !updatedBalanceID && strings.HasPrefix(f, prefix+"BalanceID.") {
			updatedBalanceID = true
			if patcher.BalanceID == nil {
				patchee.BalanceID = nil
				continue
			}
			if patchee.BalanceID == nil {
				patchee.BalanceID = &Balance{}
			}
			if o, err := DefaultApplyFieldMaskBalance(ctx, patchee.BalanceID, patcher.BalanceID, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"BalanceID.", db); err != nil {
				return nil, err
			} else {
				patchee.BalanceID = o
			}
			continue
		}
		if f == prefix+"BalanceID" {
			updatedBalanceID = true
			patchee.BalanceID = patcher.BalanceID
			continue
		}
		if f == prefix+"AccountName" {
			patchee.AccountName = patcher.AccountName
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMortgageLoanAccount executes a gorm list call
func DefaultListMortgageLoanAccount(ctx context.Context, db *gorm.DB) ([]*MortgageLoanAccount, error) {
	in := MortgageLoanAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MortgageLoanAccountORM{}, &MortgageLoanAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MortgageLoanAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageLoanAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MortgageLoanAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MortgageLoanAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageLoanAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MortgageLoanAccountORM) error
}

// DefaultCreateInterest executes a basic gorm create call
func DefaultCreateInterest(ctx context.Context, in *Interest, db *gorm.DB) (*Interest, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InterestORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InterestORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInterest(ctx context.Context, in *Interest, db *gorm.DB) (*Interest, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InterestORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InterestORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InterestORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InterestORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InterestORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InterestORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInterest(ctx context.Context, in *Interest, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InterestORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InterestORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InterestORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInterestSet(ctx context.Context, in []*Interest, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InterestORM{})).(InterestORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InterestORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InterestORM{})).(InterestORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InterestORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Interest, *gorm.DB) (*gorm.DB, error)
}
type InterestORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Interest, *gorm.DB) error
}

// DefaultStrictUpdateInterest clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInterest(ctx context.Context, in *Interest, db *gorm.DB) (*Interest, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInterest")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InterestORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InterestORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InterestORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InterestORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InterestORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInterest executes a basic gorm update call with patch behavior
func DefaultPatchInterest(ctx context.Context, in *Interest, updateMask *field_mask.FieldMask, db *gorm.DB) (*Interest, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Interest
	var err error
	if hook, ok := interface{}(&pbObj).(InterestWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInterest(ctx, &Interest{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InterestWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInterest(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InterestWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInterest(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InterestWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InterestWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Interest, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InterestWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Interest, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InterestWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Interest, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InterestWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Interest, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInterest executes a bulk gorm update call with patch behavior
func DefaultPatchSetInterest(ctx context.Context, objects []*Interest, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Interest, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Interest, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInterest(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInterest patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInterest(ctx context.Context, patchee *Interest, patcher *Interest, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Interest, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Percentage" {
			patchee.Percentage = patcher.Percentage
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInterest executes a gorm list call
func DefaultListInterest(ctx context.Context, db *gorm.DB) ([]*Interest, error) {
	in := Interest{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InterestORM{}, &Interest{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InterestORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Interest{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InterestORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InterestORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InterestORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InterestORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm.DB) error
}

// DefaultStrictUpdateAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask.FieldMask, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"Region" {
			patchee.Region = patcher.Region
			continue
		}
		if f == prefix+"Street" {
			patchee.Street = patcher.Street
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AddressORM) error
}

// DefaultCreateStudentLoanAccount executes a basic gorm create call
func DefaultCreateStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StudentLoanAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &StudentLoanAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := StudentLoanAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StudentLoanAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StudentLoanAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StudentLoanAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StudentLoanAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteStudentLoanAccountSet(ctx context.Context, in []*StudentLoanAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StudentLoanAccountORM{})).(StudentLoanAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&StudentLoanAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StudentLoanAccountORM{})).(StudentLoanAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StudentLoanAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*StudentLoanAccount, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*StudentLoanAccount, *gorm.DB) error
}

// DefaultStrictUpdateStudentLoanAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateStudentLoanAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &StudentLoanAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBalanceID := BalanceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBalanceID.StudentLoanAccountId = new(uint64)
	*filterBalanceID.StudentLoanAccountId = ormObj.Id
	if err = db.Where(filterBalanceID).Delete(BalanceORM{}).Error; err != nil {
		return nil, err
	}
	filterPslfID := PslfORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPslfID.StudentLoanAccountId = new(uint64)
	*filterPslfID.StudentLoanAccountId = ormObj.Id
	if err = db.Where(filterPslfID).Delete(PslfORM{}).Error; err != nil {
		return nil, err
	}
	filterServisorAddressID := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterServisorAddressID.StudentLoanAccountId = new(uint64)
	*filterServisorAddressID.StudentLoanAccountId = ormObj.Id
	if err = db.Where(filterServisorAddressID).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StudentLoanAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchStudentLoanAccount executes a basic gorm update call with patch behavior
func DefaultPatchStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj StudentLoanAccount
	var err error
	if hook, ok := interface{}(&pbObj).(StudentLoanAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadStudentLoanAccount(ctx, &StudentLoanAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StudentLoanAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskStudentLoanAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StudentLoanAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateStudentLoanAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StudentLoanAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StudentLoanAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetStudentLoanAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetStudentLoanAccount(ctx context.Context, objects []*StudentLoanAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*StudentLoanAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*StudentLoanAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchStudentLoanAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskStudentLoanAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStudentLoanAccount(ctx context.Context, patchee *StudentLoanAccount, patcher *StudentLoanAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*StudentLoanAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedPslfID bool
	var updatedServisorAddressID bool
	var updatedBalanceID bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PlaidAccountID" {
			patchee.PlaidAccountID = patcher.PlaidAccountID
			continue
		}
		if f == prefix+"AccountSubtype" {
			patchee.AccountSubtype = patcher.AccountSubtype
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"DisbursementDates" {
			patchee.DisbursementDates = patcher.DisbursementDates
			continue
		}
		if f == prefix+"ExpectedPayoffDate" {
			patchee.ExpectedPayoffDate = patcher.ExpectedPayoffDate
			continue
		}
		if f == prefix+"Guarantor" {
			patchee.Guarantor = patcher.Guarantor
			continue
		}
		if f == prefix+"InterestRatePercentage" {
			patchee.InterestRatePercentage = patcher.InterestRatePercentage
			continue
		}
		if f == prefix+"IsOverdue" {
			patchee.IsOverdue = patcher.IsOverdue
			continue
		}
		if f == prefix+"LastPaymentAmount" {
			patchee.LastPaymentAmount = patcher.LastPaymentAmount
			continue
		}
		if f == prefix+"LastPaymentDate" {
			patchee.LastPaymentDate = patcher.LastPaymentDate
			continue
		}
		if f == prefix+"LastStatementIssueDate" {
			patchee.LastStatementIssueDate = patcher.LastStatementIssueDate
			continue
		}
		if f == prefix+"LoanStatementIssueDate" {
			patchee.LoanStatementIssueDate = patcher.LoanStatementIssueDate
			continue
		}
		if f == prefix+"LoanName" {
			patchee.LoanName = patcher.LoanName
			continue
		}
		if f == prefix+"LoanRepaymentEndDate" {
			patchee.LoanRepaymentEndDate = patcher.LoanRepaymentEndDate
			continue
		}
		if f == prefix+"MinimumPaymentAmount" {
			patchee.MinimumPaymentAmount = patcher.MinimumPaymentAmount
			continue
		}
		if f == prefix+"NextPaymentDueDate" {
			patchee.NextPaymentDueDate = patcher.NextPaymentDueDate
			continue
		}
		if f == prefix+"OriginationDate" {
			patchee.OriginationDate = patcher.OriginationDate
			continue
		}
		if f == prefix+"OriginationPrincipalAmount" {
			patchee.OriginationPrincipalAmount = patcher.OriginationPrincipalAmount
			continue
		}
		if f == prefix+"OutstandingInterestAmount" {
			patchee.OutstandingInterestAmount = patcher.OutstandingInterestAmount
			continue
		}
		if f == prefix+"PaymentReferenceNumber" {
			patchee.PaymentReferenceNumber = patcher.PaymentReferenceNumber
			continue
		}
		if f == prefix+"SequenceNumber" {
			patchee.SequenceNumber = patcher.SequenceNumber
			continue
		}
		if !updatedPslfID && strings.HasPrefix(f, prefix+"PslfID.") {
			updatedPslfID = true
			if patcher.PslfID == nil {
				patchee.PslfID = nil
				continue
			}
			if patchee.PslfID == nil {
				patchee.PslfID = &Pslf{}
			}
			if o, err := DefaultApplyFieldMaskPslf(ctx, patchee.PslfID, patcher.PslfID, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PslfID.", db); err != nil {
				return nil, err
			} else {
				patchee.PslfID = o
			}
			continue
		}
		if f == prefix+"PslfID" {
			updatedPslfID = true
			patchee.PslfID = patcher.PslfID
			continue
		}
		if f == prefix+"RepaymentPlan" {
			patchee.RepaymentPlan = patcher.RepaymentPlan
			continue
		}
		if !updatedServisorAddressID && strings.HasPrefix(f, prefix+"ServisorAddressID.") {
			updatedServisorAddressID = true
			if patcher.ServisorAddressID == nil {
				patchee.ServisorAddressID = nil
				continue
			}
			if patchee.ServisorAddressID == nil {
				patchee.ServisorAddressID = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.ServisorAddressID, patcher.ServisorAddressID, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ServisorAddressID.", db); err != nil {
				return nil, err
			} else {
				patchee.ServisorAddressID = o
			}
			continue
		}
		if f == prefix+"ServisorAddressID" {
			updatedServisorAddressID = true
			patchee.ServisorAddressID = patcher.ServisorAddressID
			continue
		}
		if f == prefix+"InterestPaidYTD" {
			patchee.InterestPaidYTD = patcher.InterestPaidYTD
			continue
		}
		if f == prefix+"PrincipalPaidYTD" {
			patchee.PrincipalPaidYTD = patcher.PrincipalPaidYTD
			continue
		}
		if !updatedBalanceID && strings.HasPrefix(f, prefix+"BalanceID.") {
			updatedBalanceID = true
			if patcher.BalanceID == nil {
				patchee.BalanceID = nil
				continue
			}
			if patchee.BalanceID == nil {
				patchee.BalanceID = &Balance{}
			}
			if o, err := DefaultApplyFieldMaskBalance(ctx, patchee.BalanceID, patcher.BalanceID, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"BalanceID.", db); err != nil {
				return nil, err
			} else {
				patchee.BalanceID = o
			}
			continue
		}
		if f == prefix+"BalanceID" {
			updatedBalanceID = true
			patchee.BalanceID = patcher.BalanceID
			continue
		}
		if f == prefix+"AccountName" {
			patchee.AccountName = patcher.AccountName
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStudentLoanAccount executes a gorm list call
func DefaultListStudentLoanAccount(ctx context.Context, db *gorm.DB) ([]*StudentLoanAccount, error) {
	in := StudentLoanAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &StudentLoanAccountORM{}, &StudentLoanAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StudentLoanAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*StudentLoanAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StudentLoanAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]StudentLoanAccountORM) error
}

// DefaultCreatePslf executes a basic gorm create call
func DefaultCreatePslf(ctx context.Context, in *Pslf, db *gorm.DB) (*Pslf, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PslfORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PslfORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPslf(ctx context.Context, in *Pslf, db *gorm.DB) (*Pslf, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PslfORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PslfORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PslfORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PslfORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PslfORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PslfORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePslf(ctx context.Context, in *Pslf, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PslfORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PslfORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PslfORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePslfSet(ctx context.Context, in []*Pslf, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PslfORM{})).(PslfORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PslfORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PslfORM{})).(PslfORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PslfORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Pslf, *gorm.DB) (*gorm.DB, error)
}
type PslfORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Pslf, *gorm.DB) error
}

// DefaultStrictUpdatePslf clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePslf(ctx context.Context, in *Pslf, db *gorm.DB) (*Pslf, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePslf")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PslfORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PslfORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PslfORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PslfORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PslfORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPslf executes a basic gorm update call with patch behavior
func DefaultPatchPslf(ctx context.Context, in *Pslf, updateMask *field_mask.FieldMask, db *gorm.DB) (*Pslf, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Pslf
	var err error
	if hook, ok := interface{}(&pbObj).(PslfWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPslf(ctx, &Pslf{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PslfWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPslf(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PslfWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePslf(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PslfWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PslfWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Pslf, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PslfWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Pslf, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PslfWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Pslf, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PslfWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Pslf, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPslf executes a bulk gorm update call with patch behavior
func DefaultPatchSetPslf(ctx context.Context, objects []*Pslf, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Pslf, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Pslf, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPslf(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPslf patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPslf(ctx context.Context, patchee *Pslf, patcher *Pslf, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Pslf, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"EstimatedEligibilityDate" {
			patchee.EstimatedEligibilityDate = patcher.EstimatedEligibilityDate
			continue
		}
		if f == prefix+"PaymentsMade" {
			patchee.PaymentsMade = patcher.PaymentsMade
			continue
		}
		if f == prefix+"PaymentsRemaining" {
			patchee.PaymentsRemaining = patcher.PaymentsRemaining
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPslf executes a gorm list call
func DefaultListPslf(ctx context.Context, db *gorm.DB) ([]*Pslf, error) {
	in := Pslf{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PslfORM{}, &Pslf{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PslfORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PslfORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Pslf{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PslfORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PslfORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PslfORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PslfORM) error
}

// DefaultCreateInvestmentAccount executes a basic gorm create call
func DefaultCreateInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvestmentAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvestmentAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvestmentAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvestmentAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvestmentAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentAccountSet(ctx context.Context, in []*InvestmentAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvestmentAccountORM{})).(InvestmentAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvestmentAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvestmentAccountORM{})).(InvestmentAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvestmentAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvestmentAccount, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvestmentAccount, *gorm.DB) error
}

// DefaultStrictUpdateInvestmentAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvestmentAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvestmentAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBalanceID := BalanceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBalanceID.InvestmentAccountId = new(uint64)
	*filterBalanceID.InvestmentAccountId = ormObj.Id
	if err = db.Where(filterBalanceID).Delete(BalanceORM{}).Error; err != nil {
		return nil, err
	}
	filterSecurityID := SecurityORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSecurityID.InvestmentAccountId = new(uint64)
	*filterSecurityID.InvestmentAccountId = ormObj.Id
	if err = db.Where(filterSecurityID).Delete(SecurityORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvestmentAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvestmentAccount executes a basic gorm update call with patch behavior
func DefaultPatchInvestmentAccount(ctx context.Context, in *InvestmentAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvestmentAccount
	var err error
	if hook, ok := interface{}(&pbObj).(InvestmentAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvestmentAccount(ctx, &InvestmentAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvestmentAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvestmentAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvestmentAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvestmentAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvestmentAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvestmentAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvestmentAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvestmentAccount(ctx context.Context, objects []*InvestmentAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvestmentAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvestmentAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvestmentAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvestmentAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestmentAccount(ctx context.Context, patchee *InvestmentAccount, patcher *InvestmentAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvestmentAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedBalanceID bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PlaidAccountID" {
			patchee.PlaidAccountID = patcher.PlaidAccountID
			continue
		}
		if f == prefix+"AccountSubtype" {
			patchee.AccountSubtype = patcher.AccountSubtype
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"AccountName" {
			patchee.AccountName = patcher.AccountName
			continue
		}
		if !updatedBalanceID && strings.HasPrefix(f, prefix+"BalanceID.") {
			updatedBalanceID = true
			if patcher.BalanceID == nil {
				patchee.BalanceID = nil
				continue
			}
			if patchee.BalanceID == nil {
				patchee.BalanceID = &Balance{}
			}
			if o, err := DefaultApplyFieldMaskBalance(ctx, patchee.BalanceID, patcher.BalanceID, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"BalanceID.", db); err != nil {
				return nil, err
			} else {
				patchee.BalanceID = o
			}
			continue
		}
		if f == prefix+"BalanceID" {
			updatedBalanceID = true
			patchee.BalanceID = patcher.BalanceID
			continue
		}
		if f == prefix+"SecurityID" {
			patchee.SecurityID = patcher.SecurityID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestmentAccount executes a gorm list call
func DefaultListInvestmentAccount(ctx context.Context, db *gorm.DB) ([]*InvestmentAccount, error) {
	in := InvestmentAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvestmentAccountORM{}, &InvestmentAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvestmentAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvestmentAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestmentAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvestmentAccountORM) error
}
