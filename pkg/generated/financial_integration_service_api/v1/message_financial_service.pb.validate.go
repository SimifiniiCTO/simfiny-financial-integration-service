// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: financial_integration_service_api/v1/message_financial_service.proto

package financial_integration_service_apiv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on StripeSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StripeSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StripeSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StripeSubscriptionMultiError, or nil if none found.
func (m *StripeSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *StripeSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for StripeSubscriptionId

	// no validation rules for StripeSubscriptionStatus

	// no validation rules for StripeSubscriptionActiveUntil

	// no validation rules for StripeWebhookLatestTimestamp

	// no validation rules for IsTrialing

	if len(errors) > 0 {
		return StripeSubscriptionMultiError(errors)
	}

	return nil
}

// StripeSubscriptionMultiError is an error wrapping multiple validation errors
// returned by StripeSubscription.ValidateAll() if the designated constraints
// aren't met.
type StripeSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StripeSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StripeSubscriptionMultiError) AllErrors() []error { return m }

// StripeSubscriptionValidationError is the validation error returned by
// StripeSubscription.Validate if the designated constraints aren't met.
type StripeSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StripeSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StripeSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StripeSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StripeSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StripeSubscriptionValidationError) ErrorName() string {
	return "StripeSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e StripeSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStripeSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StripeSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StripeSubscriptionValidationError{}

// Validate checks the field values on UserProfile with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserProfile with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserProfileMultiError, or
// nil if none found.
func (m *UserProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *UserProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.GetUserId() <= 0 {
		err := UserProfileValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for StripeCustomerId

	if all {
		switch v := interface{}(m.GetStripeSubscriptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserProfileValidationError{
					field:  "StripeSubscriptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserProfileValidationError{
					field:  "StripeSubscriptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStripeSubscriptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserProfileValidationError{
				field:  "StripeSubscriptions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLink() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserProfileValidationError{
						field:  fmt.Sprintf("Link[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserProfileValidationError{
						field:  fmt.Sprintf("Link[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserProfileValidationError{
					field:  fmt.Sprintf("Link[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetActionableInsights() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserProfileValidationError{
						field:  fmt.Sprintf("ActionableInsights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserProfileValidationError{
						field:  fmt.Sprintf("ActionableInsights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserProfileValidationError{
					field:  fmt.Sprintf("ActionableInsights[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserProfileMultiError(errors)
	}

	return nil
}

// UserProfileMultiError is an error wrapping multiple validation errors
// returned by UserProfile.ValidateAll() if the designated constraints aren't met.
type UserProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserProfileMultiError) AllErrors() []error { return m }

// UserProfileValidationError is the validation error returned by
// UserProfile.Validate if the designated constraints aren't met.
type UserProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserProfileValidationError) ErrorName() string { return "UserProfileValidationError" }

// Error satisfies the builtin error interface
func (e UserProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserProfileValidationError{}

// Validate checks the field values on ActionableInsight with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ActionableInsight) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionableInsight with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActionableInsightMultiError, or nil if none found.
func (m *ActionableInsight) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionableInsight) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DetailedAction

	// no validation rules for SummarizedAction

	if all {
		switch v := interface{}(m.GetGeneratedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionableInsightValidationError{
					field:  "GeneratedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionableInsightValidationError{
					field:  "GeneratedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeneratedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionableInsightValidationError{
				field:  "GeneratedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ActionableInsightMultiError(errors)
	}

	return nil
}

// ActionableInsightMultiError is an error wrapping multiple validation errors
// returned by ActionableInsight.ValidateAll() if the designated constraints
// aren't met.
type ActionableInsightMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionableInsightMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionableInsightMultiError) AllErrors() []error { return m }

// ActionableInsightValidationError is the validation error returned by
// ActionableInsight.Validate if the designated constraints aren't met.
type ActionableInsightValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionableInsightValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionableInsightValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionableInsightValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionableInsightValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionableInsightValidationError) ErrorName() string {
	return "ActionableInsightValidationError"
}

// Error satisfies the builtin error interface
func (e ActionableInsightValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionableInsight.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionableInsightValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionableInsightValidationError{}

// Validate checks the field values on Link with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Link) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Link with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LinkMultiError, or nil if none found.
func (m *Link) ValidateAll() error {
	return m.validate(true)
}

func (m *Link) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetPlaidSync()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "PlaidSync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "PlaidSync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlaidSync()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkValidationError{
				field:  "PlaidSync",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LinkStatus

	if all {
		switch v := interface{}(m.GetPlaidLink()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "PlaidLink",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "PlaidLink",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlaidLink()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkValidationError{
				field:  "PlaidLink",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PlaidNewAccountsAvailable

	// no validation rules for ExpirationDate

	// no validation rules for InstitutionName

	// no validation rules for CustomInstitutionName

	// no validation rules for Description

	// no validation rules for LastManualSync

	// no validation rules for LastSuccessfulUpdate

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBankAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("BankAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("BankAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("BankAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvestmentAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("InvestmentAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("InvestmentAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("InvestmentAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCreditAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("CreditAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("CreditAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("CreditAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMortgageAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("MortgageAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("MortgageAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("MortgageAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetStudentLoanAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("StudentLoanAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("StudentLoanAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("StudentLoanAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PlaidInstitutionId

	// no validation rules for LinkType

	// no validation rules for ErrorCode

	// no validation rules for UpdatedAt

	// no validation rules for NewAccountsAvailable

	// no validation rules for ShouldBeUpdated

	if len(errors) > 0 {
		return LinkMultiError(errors)
	}

	return nil
}

// LinkMultiError is an error wrapping multiple validation errors returned by
// Link.ValidateAll() if the designated constraints aren't met.
type LinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkMultiError) AllErrors() []error { return m }

// LinkValidationError is the validation error returned by Link.Validate if the
// designated constraints aren't met.
type LinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkValidationError) ErrorName() string { return "LinkValidationError" }

// Error satisfies the builtin error interface
func (e LinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkValidationError{}

// Validate checks the field values on PlaidSync with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlaidSync) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidSync with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlaidSyncMultiError, or nil
// if none found.
func (m *PlaidSync) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidSync) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TimeStamp

	// no validation rules for Trigger

	// no validation rules for NextCursor

	// no validation rules for Added

	// no validation rules for Removed

	// no validation rules for Modified

	if len(errors) > 0 {
		return PlaidSyncMultiError(errors)
	}

	return nil
}

// PlaidSyncMultiError is an error wrapping multiple validation errors returned
// by PlaidSync.ValidateAll() if the designated constraints aren't met.
type PlaidSyncMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidSyncMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidSyncMultiError) AllErrors() []error { return m }

// PlaidSyncValidationError is the validation error returned by
// PlaidSync.Validate if the designated constraints aren't met.
type PlaidSyncValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidSyncValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidSyncValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidSyncValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidSyncValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidSyncValidationError) ErrorName() string { return "PlaidSyncValidationError" }

// Error satisfies the builtin error interface
func (e PlaidSyncValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidSync.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidSyncValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidSyncValidationError{}

// Validate checks the field values on Token with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Token) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Token with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TokenMultiError, or nil if none found.
func (m *Token) ValidateAll() error {
	return m.validate(true)
}

func (m *Token) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ItemId

	// no validation rules for KeyId

	// no validation rules for AccessToken

	// no validation rules for Version

	if len(errors) > 0 {
		return TokenMultiError(errors)
	}

	return nil
}

// TokenMultiError is an error wrapping multiple validation errors returned by
// Token.ValidateAll() if the designated constraints aren't met.
type TokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenMultiError) AllErrors() []error { return m }

// TokenValidationError is the validation error returned by Token.Validate if
// the designated constraints aren't met.
type TokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenValidationError) ErrorName() string { return "TokenValidationError" }

// Error satisfies the builtin error interface
func (e TokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenValidationError{}

// Validate checks the field values on PlaidLink with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlaidLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidLink with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlaidLinkMultiError, or nil
// if none found.
func (m *PlaidLink) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for WebhookUrl

	// no validation rules for InstitutionId

	// no validation rules for InstitutionName

	// no validation rules for UsePlaidSync

	// no validation rules for ItemId

	if len(errors) > 0 {
		return PlaidLinkMultiError(errors)
	}

	return nil
}

// PlaidLinkMultiError is an error wrapping multiple validation errors returned
// by PlaidLink.ValidateAll() if the designated constraints aren't met.
type PlaidLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidLinkMultiError) AllErrors() []error { return m }

// PlaidLinkValidationError is the validation error returned by
// PlaidLink.Validate if the designated constraints aren't met.
type PlaidLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidLinkValidationError) ErrorName() string { return "PlaidLinkValidationError" }

// Error satisfies the builtin error interface
func (e PlaidLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidLinkValidationError{}

// Validate checks the field values on StudentLoanAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StudentLoanAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StudentLoanAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StudentLoanAccountMultiError, or nil if none found.
func (m *StudentLoanAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *StudentLoanAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for PlaidAccountId

	// no validation rules for ExpectedPayoffDate

	// no validation rules for Guarantor

	// no validation rules for InterestRatePercentage

	// no validation rules for IsOverdue

	// no validation rules for LastPaymentAmount

	// no validation rules for LastPaymentDate

	// no validation rules for LastStatementIssueDate

	// no validation rules for LoanName

	// no validation rules for LoanEndDate

	// no validation rules for MinimumPaymentAmount

	// no validation rules for NextPaymentDueDate

	// no validation rules for OriginationDate

	// no validation rules for OriginationPrincipalAmount

	// no validation rules for OutstandingInterestAmount

	// no validation rules for PaymentReferenceNumber

	// no validation rules for SequenceNumber

	// no validation rules for YtdInterestPaid

	// no validation rules for YtdPrincipalPaid

	// no validation rules for LoanType

	// no validation rules for PslfStatusEstimatedEligibilityDate

	// no validation rules for PslfStatusPaymentsMade

	// no validation rules for PslfStatusPaymentsRemaining

	// no validation rules for RepaymentPlanType

	// no validation rules for RepaymentPlanDescription

	// no validation rules for ServicerAddressCity

	// no validation rules for ServicerAddressPostalCode

	// no validation rules for ServicerAddressState

	// no validation rules for ServicerAddressStreet

	// no validation rules for ServicerAddressRegion

	// no validation rules for ServicerAddressCountry

	// no validation rules for UserId

	// no validation rules for Name

	if len(errors) > 0 {
		return StudentLoanAccountMultiError(errors)
	}

	return nil
}

// StudentLoanAccountMultiError is an error wrapping multiple validation errors
// returned by StudentLoanAccount.ValidateAll() if the designated constraints
// aren't met.
type StudentLoanAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StudentLoanAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StudentLoanAccountMultiError) AllErrors() []error { return m }

// StudentLoanAccountValidationError is the validation error returned by
// StudentLoanAccount.Validate if the designated constraints aren't met.
type StudentLoanAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StudentLoanAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StudentLoanAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StudentLoanAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StudentLoanAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StudentLoanAccountValidationError) ErrorName() string {
	return "StudentLoanAccountValidationError"
}

// Error satisfies the builtin error interface
func (e StudentLoanAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStudentLoanAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StudentLoanAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StudentLoanAccountValidationError{}

// Validate checks the field values on CreditAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreditAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreditAccountMultiError, or
// nil if none found.
func (m *CreditAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for Name

	// no validation rules for Number

	// no validation rules for Type

	// no validation rules for Balance

	// no validation rules for CurrentFunds

	// no validation rules for BalanceLimit

	// no validation rules for PlaidAccountId

	// no validation rules for Subtype

	// no validation rules for IsOverdue

	// no validation rules for LastPaymentAmount

	// no validation rules for LastPaymentDate

	// no validation rules for LastStatementIssueDate

	// no validation rules for MinimumAmountDueDate

	// no validation rules for NextPaymentDate

	for idx, item := range m.GetAprs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreditAccountValidationError{
						field:  fmt.Sprintf("Aprs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreditAccountValidationError{
						field:  fmt.Sprintf("Aprs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreditAccountValidationError{
					field:  fmt.Sprintf("Aprs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for LastStatementBalance

	// no validation rules for MinimumPaymentAmount

	// no validation rules for NextPaymentDueDate

	if len(errors) > 0 {
		return CreditAccountMultiError(errors)
	}

	return nil
}

// CreditAccountMultiError is an error wrapping multiple validation errors
// returned by CreditAccount.ValidateAll() if the designated constraints
// aren't met.
type CreditAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditAccountMultiError) AllErrors() []error { return m }

// CreditAccountValidationError is the validation error returned by
// CreditAccount.Validate if the designated constraints aren't met.
type CreditAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditAccountValidationError) ErrorName() string { return "CreditAccountValidationError" }

// Error satisfies the builtin error interface
func (e CreditAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditAccountValidationError{}

// Validate checks the field values on MortgageAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MortgageAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MortgageAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MortgageAccountMultiError, or nil if none found.
func (m *MortgageAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *MortgageAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for PlaidAccountId

	// no validation rules for AccountNumber

	// no validation rules for CurrentLateFee

	// no validation rules for EscrowBalance

	// no validation rules for HasPmi

	// no validation rules for HasPrepaymentPenalty

	// no validation rules for LastPaymentAmount

	// no validation rules for LastPaymentDate

	// no validation rules for LoanTerm

	// no validation rules for LoanTypeDescription

	// no validation rules for MaturityDate

	// no validation rules for NextMonthlyPayment

	// no validation rules for NextPaymentDueDate

	// no validation rules for OriginalPrincipalBalance

	// no validation rules for OriginalPropertyValue

	// no validation rules for OutstandingPrincipalBalance

	// no validation rules for PaymentAmount

	// no validation rules for PaymentDate

	// no validation rules for OriginationDate

	// no validation rules for OriginationPrincipalAmount

	// no validation rules for PastDueAmount

	// no validation rules for YtdInterestPaid

	// no validation rules for YtdPrincipalPaid

	// no validation rules for PropertyAddressCity

	// no validation rules for PropertyAddressState

	// no validation rules for PropertyAddressStreet

	// no validation rules for PropertyAddressPostalCode

	// no validation rules for PropertyRegion

	// no validation rules for PropertyCountry

	// no validation rules for InterestRatePercentage

	// no validation rules for InterestRateType

	if len(errors) > 0 {
		return MortgageAccountMultiError(errors)
	}

	return nil
}

// MortgageAccountMultiError is an error wrapping multiple validation errors
// returned by MortgageAccount.ValidateAll() if the designated constraints
// aren't met.
type MortgageAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MortgageAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MortgageAccountMultiError) AllErrors() []error { return m }

// MortgageAccountValidationError is the validation error returned by
// MortgageAccount.Validate if the designated constraints aren't met.
type MortgageAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MortgageAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MortgageAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MortgageAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MortgageAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MortgageAccountValidationError) ErrorName() string { return "MortgageAccountValidationError" }

// Error satisfies the builtin error interface
func (e MortgageAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMortgageAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MortgageAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MortgageAccountValidationError{}

// Validate checks the field values on InvestmentAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvestmentAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvestmentAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvestmentAccountMultiError, or nil if none found.
func (m *InvestmentAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *InvestmentAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for Name

	// no validation rules for Number

	// no validation rules for Type

	// no validation rules for Balance

	// no validation rules for CurrentFunds

	// no validation rules for BalanceLimit

	// no validation rules for PlaidAccountId

	// no validation rules for Subtype

	for idx, item := range m.GetHoldings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvestmentAccountValidationError{
						field:  fmt.Sprintf("Holdings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvestmentAccountValidationError{
						field:  fmt.Sprintf("Holdings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvestmentAccountValidationError{
					field:  fmt.Sprintf("Holdings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSecurities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvestmentAccountValidationError{
						field:  fmt.Sprintf("Securities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvestmentAccountValidationError{
						field:  fmt.Sprintf("Securities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvestmentAccountValidationError{
					field:  fmt.Sprintf("Securities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InvestmentAccountMultiError(errors)
	}

	return nil
}

// InvestmentAccountMultiError is an error wrapping multiple validation errors
// returned by InvestmentAccount.ValidateAll() if the designated constraints
// aren't met.
type InvestmentAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvestmentAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvestmentAccountMultiError) AllErrors() []error { return m }

// InvestmentAccountValidationError is the validation error returned by
// InvestmentAccount.Validate if the designated constraints aren't met.
type InvestmentAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvestmentAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvestmentAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvestmentAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvestmentAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvestmentAccountValidationError) ErrorName() string {
	return "InvestmentAccountValidationError"
}

// Error satisfies the builtin error interface
func (e InvestmentAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvestmentAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvestmentAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvestmentAccountValidationError{}

// Validate checks the field values on BankAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BankAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BankAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BankAccountMultiError, or
// nil if none found.
func (m *BankAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *BankAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.GetUserId() <= 0 {
		err := BankAccountValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Number

	// no validation rules for Type

	// no validation rules for Balance

	// no validation rules for Currency

	// no validation rules for CurrentFunds

	// no validation rules for BalanceLimit

	for idx, item := range m.GetPockets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BankAccountValidationError{
						field:  fmt.Sprintf("Pockets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BankAccountValidationError{
						field:  fmt.Sprintf("Pockets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BankAccountValidationError{
					field:  fmt.Sprintf("Pockets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PlaidAccountId

	// no validation rules for Subtype

	// no validation rules for Status

	if len(errors) > 0 {
		return BankAccountMultiError(errors)
	}

	return nil
}

// BankAccountMultiError is an error wrapping multiple validation errors
// returned by BankAccount.ValidateAll() if the designated constraints aren't met.
type BankAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BankAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BankAccountMultiError) AllErrors() []error { return m }

// BankAccountValidationError is the validation error returned by
// BankAccount.Validate if the designated constraints aren't met.
type BankAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BankAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BankAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BankAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BankAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BankAccountValidationError) ErrorName() string { return "BankAccountValidationError" }

// Error satisfies the builtin error interface
func (e BankAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBankAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BankAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BankAccountValidationError{}

// Validate checks the field values on Pocket with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Pocket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Pocket with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PocketMultiError, or nil if none found.
func (m *Pocket) ValidateAll() error {
	return m.validate(true)
}

func (m *Pocket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetGoals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PocketValidationError{
						field:  fmt.Sprintf("Goals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PocketValidationError{
						field:  fmt.Sprintf("Goals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PocketValidationError{
					field:  fmt.Sprintf("Goals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Type

	if len(errors) > 0 {
		return PocketMultiError(errors)
	}

	return nil
}

// PocketMultiError is an error wrapping multiple validation errors returned by
// Pocket.ValidateAll() if the designated constraints aren't met.
type PocketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PocketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PocketMultiError) AllErrors() []error { return m }

// PocketValidationError is the validation error returned by Pocket.Validate if
// the designated constraints aren't met.
type PocketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PocketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PocketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PocketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PocketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PocketValidationError) ErrorName() string { return "PocketValidationError" }

// Error satisfies the builtin error interface
func (e PocketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPocket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PocketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PocketValidationError{}

// Validate checks the field values on SmartGoal with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SmartGoal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SmartGoal with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SmartGoalMultiError, or nil
// if none found.
func (m *SmartGoal) ValidateAll() error {
	return m.validate(true)
}

func (m *SmartGoal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	if len(m.GetName()) < 3 {
		err := SmartGoalValidationError{
			field:  "Name",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDescription()) < 3 {
		err := SmartGoalValidationError{
			field:  "Description",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsCompleted

	// no validation rules for GoalType

	if len(m.GetDuration()) < 3 {
		err := SmartGoalValidationError{
			field:  "Duration",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetStartDate()) < 3 {
		err := SmartGoalValidationError{
			field:  "StartDate",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetEndDate()) < 3 {
		err := SmartGoalValidationError{
			field:  "EndDate",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTargetAmount()) < 1 {
		err := SmartGoalValidationError{
			field:  "TargetAmount",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCurrentAmount()) < 0 {
		err := SmartGoalValidationError{
			field:  "CurrentAmount",
			reason: "value length must be at least 0 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMilestones() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SmartGoalValidationError{
						field:  fmt.Sprintf("Milestones[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SmartGoalValidationError{
						field:  fmt.Sprintf("Milestones[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SmartGoalValidationError{
					field:  fmt.Sprintf("Milestones[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetForecasts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SmartGoalValidationError{
					field:  "Forecasts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SmartGoalValidationError{
					field:  "Forecasts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetForecasts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SmartGoalValidationError{
				field:  "Forecasts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SmartGoalMultiError(errors)
	}

	return nil
}

// SmartGoalMultiError is an error wrapping multiple validation errors returned
// by SmartGoal.ValidateAll() if the designated constraints aren't met.
type SmartGoalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SmartGoalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SmartGoalMultiError) AllErrors() []error { return m }

// SmartGoalValidationError is the validation error returned by
// SmartGoal.Validate if the designated constraints aren't met.
type SmartGoalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SmartGoalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SmartGoalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SmartGoalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SmartGoalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SmartGoalValidationError) ErrorName() string { return "SmartGoalValidationError" }

// Error satisfies the builtin error interface
func (e SmartGoalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSmartGoal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SmartGoalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SmartGoalValidationError{}

// Validate checks the field values on Forecast with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Forecast) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Forecast with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ForecastMultiError, or nil
// if none found.
func (m *Forecast) ValidateAll() error {
	return m.validate(true)
}

func (m *Forecast) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetForecastedAmount()) < 3 {
		err := ForecastValidationError{
			field:  "ForecastedAmount",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetForecastedCompletionDate()) < 3 {
		err := ForecastValidationError{
			field:  "ForecastedCompletionDate",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetVarianceAmount()) < 3 {
		err := ForecastValidationError{
			field:  "VarianceAmount",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ForecastMultiError(errors)
	}

	return nil
}

// ForecastMultiError is an error wrapping multiple validation errors returned
// by Forecast.ValidateAll() if the designated constraints aren't met.
type ForecastMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForecastMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForecastMultiError) AllErrors() []error { return m }

// ForecastValidationError is the validation error returned by
// Forecast.Validate if the designated constraints aren't met.
type ForecastValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForecastValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForecastValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForecastValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForecastValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForecastValidationError) ErrorName() string { return "ForecastValidationError" }

// Error satisfies the builtin error interface
func (e ForecastValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForecast.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForecastValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForecastValidationError{}

// Validate checks the field values on Milestone with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Milestone) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Milestone with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MilestoneMultiError, or nil
// if none found.
func (m *Milestone) ValidateAll() error {
	return m.validate(true)
}

func (m *Milestone) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetName()) < 3 {
		err := MilestoneValidationError{
			field:  "Name",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDescription()) < 3 {
		err := MilestoneValidationError{
			field:  "Description",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTargetDate()) < 10 {
		err := MilestoneValidationError{
			field:  "TargetDate",
			reason: "value length must be at least 10 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTargetAmount()) < 3 {
		err := MilestoneValidationError{
			field:  "TargetAmount",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsCompleted

	if all {
		switch v := interface{}(m.GetBudget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MilestoneValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MilestoneValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBudget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MilestoneValidationError{
				field:  "Budget",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MilestoneMultiError(errors)
	}

	return nil
}

// MilestoneMultiError is an error wrapping multiple validation errors returned
// by Milestone.ValidateAll() if the designated constraints aren't met.
type MilestoneMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MilestoneMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MilestoneMultiError) AllErrors() []error { return m }

// MilestoneValidationError is the validation error returned by
// Milestone.Validate if the designated constraints aren't met.
type MilestoneValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MilestoneValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MilestoneValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MilestoneValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MilestoneValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MilestoneValidationError) ErrorName() string { return "MilestoneValidationError" }

// Error satisfies the builtin error interface
func (e MilestoneValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMilestone.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MilestoneValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MilestoneValidationError{}

// Validate checks the field values on Budget with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Budget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Budget with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BudgetMultiError, or nil if none found.
func (m *Budget) ValidateAll() error {
	return m.validate(true)
}

func (m *Budget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetName()) < 10 {
		err := BudgetValidationError{
			field:  "Name",
			reason: "value length must be at least 10 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	// no validation rules for StartDate

	// no validation rules for EndDate

	if all {
		switch v := interface{}(m.GetCategory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetValidationError{
					field:  "Category",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetValidationError{
					field:  "Category",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCategory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetValidationError{
				field:  "Category",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BudgetMultiError(errors)
	}

	return nil
}

// BudgetMultiError is an error wrapping multiple validation errors returned by
// Budget.ValidateAll() if the designated constraints aren't met.
type BudgetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BudgetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BudgetMultiError) AllErrors() []error { return m }

// BudgetValidationError is the validation error returned by Budget.Validate if
// the designated constraints aren't met.
type BudgetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BudgetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BudgetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BudgetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BudgetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BudgetValidationError) ErrorName() string { return "BudgetValidationError" }

// Error satisfies the builtin error interface
func (e BudgetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBudget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BudgetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BudgetValidationError{}

// Validate checks the field values on Category with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Category) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Category with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CategoryMultiError, or nil
// if none found.
func (m *Category) ValidateAll() error {
	return m.validate(true)
}

func (m *Category) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetName()) < 3 {
		err := CategoryValidationError{
			field:  "Name",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDescription()) < 10 {
		err := CategoryValidationError{
			field:  "Description",
			reason: "value length must be at least 10 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CategoryMultiError(errors)
	}

	return nil
}

// CategoryMultiError is an error wrapping multiple validation errors returned
// by Category.ValidateAll() if the designated constraints aren't met.
type CategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryMultiError) AllErrors() []error { return m }

// CategoryValidationError is the validation error returned by
// Category.Validate if the designated constraints aren't met.
type CategoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryValidationError) ErrorName() string { return "CategoryValidationError" }

// Error satisfies the builtin error interface
func (e CategoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryValidationError{}

// Validate checks the field values on InvesmentHolding with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvesmentHolding) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvesmentHolding with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvesmentHoldingMultiError, or nil if none found.
func (m *InvesmentHolding) ValidateAll() error {
	return m.validate(true)
}

func (m *InvesmentHolding) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetName()) < 3 {
		err := InvesmentHoldingValidationError{
			field:  "Name",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PlaidAccountId

	// no validation rules for CostBasis

	// no validation rules for InstitutionPrice

	// no validation rules for InstitutionPriceAsOf

	// no validation rules for InstitutionPriceDatetime

	// no validation rules for InstitutionValue

	// no validation rules for IsoCurrencyCode

	// no validation rules for Quantity

	// no validation rules for SecurityId

	// no validation rules for UnofficialCurrencyCode

	if len(errors) > 0 {
		return InvesmentHoldingMultiError(errors)
	}

	return nil
}

// InvesmentHoldingMultiError is an error wrapping multiple validation errors
// returned by InvesmentHolding.ValidateAll() if the designated constraints
// aren't met.
type InvesmentHoldingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvesmentHoldingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvesmentHoldingMultiError) AllErrors() []error { return m }

// InvesmentHoldingValidationError is the validation error returned by
// InvesmentHolding.Validate if the designated constraints aren't met.
type InvesmentHoldingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvesmentHoldingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvesmentHoldingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvesmentHoldingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvesmentHoldingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvesmentHoldingValidationError) ErrorName() string { return "InvesmentHoldingValidationError" }

// Error satisfies the builtin error interface
func (e InvesmentHoldingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvesmentHolding.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvesmentHoldingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvesmentHoldingValidationError{}

// Validate checks the field values on InvestmentSecurity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvestmentSecurity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvestmentSecurity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvestmentSecurityMultiError, or nil if none found.
func (m *InvestmentSecurity) ValidateAll() error {
	return m.validate(true)
}

func (m *InvestmentSecurity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ClosePrice

	// no validation rules for ClosePriceAsOf

	// no validation rules for Cusip

	// no validation rules for InstitutionId

	// no validation rules for InstitutionSecurityId

	// no validation rules for IsCashEquivalent

	// no validation rules for Isin

	// no validation rules for IsoCurrencyCode

	// no validation rules for Name

	// no validation rules for ProxySecurityId

	// no validation rules for SecurityId

	// no validation rules for Sedol

	// no validation rules for TickerSymbol

	// no validation rules for Type

	// no validation rules for UnofficialCurrencyCode

	// no validation rules for UpdateDatetime

	if len(errors) > 0 {
		return InvestmentSecurityMultiError(errors)
	}

	return nil
}

// InvestmentSecurityMultiError is an error wrapping multiple validation errors
// returned by InvestmentSecurity.ValidateAll() if the designated constraints
// aren't met.
type InvestmentSecurityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvestmentSecurityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvestmentSecurityMultiError) AllErrors() []error { return m }

// InvestmentSecurityValidationError is the validation error returned by
// InvestmentSecurity.Validate if the designated constraints aren't met.
type InvestmentSecurityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvestmentSecurityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvestmentSecurityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvestmentSecurityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvestmentSecurityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvestmentSecurityValidationError) ErrorName() string {
	return "InvestmentSecurityValidationError"
}

// Error satisfies the builtin error interface
func (e InvestmentSecurityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvestmentSecurity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvestmentSecurityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvestmentSecurityValidationError{}

// Validate checks the field values on Apr with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Apr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Apr with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AprMultiError, or nil if none found.
func (m *Apr) ValidateAll() error {
	return m.validate(true)
}

func (m *Apr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Percentage

	// no validation rules for Type

	// no validation rules for BalanceSubjectToApr

	// no validation rules for InterestChargeAmount

	if len(errors) > 0 {
		return AprMultiError(errors)
	}

	return nil
}

// AprMultiError is an error wrapping multiple validation errors returned by
// Apr.ValidateAll() if the designated constraints aren't met.
type AprMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AprMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AprMultiError) AllErrors() []error { return m }

// AprValidationError is the validation error returned by Apr.Validate if the
// designated constraints aren't met.
type AprValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AprValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AprValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AprValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AprValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AprValidationError) ErrorName() string { return "AprValidationError" }

// Error satisfies the builtin error interface
func (e AprValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AprValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AprValidationError{}
