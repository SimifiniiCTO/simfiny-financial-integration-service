package financial_integration_service_apiv1

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

type InvestmentTransactionORM struct {
	AccountId               string
	Ammount                 string
	Amount                  float64
	CreatedAt               string
	Date                    string
	Fees                    float64
	Id                      uint64
	InvestmentTransactionId string
	IsoCurrencyCode         string
	LinkId                  uint64
	Name                    string
	Price                   float64
	Quantity                float64
	SecurityId              string
	Sign                    int32
	Subtype                 string
	Type                    string
	UnofficialCurrencyCode  string
	UserId                  uint64
}

// TableName overrides the default tablename generated by GORM
func (InvestmentTransactionORM) TableName() string {
	return "investment_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvestmentTransaction) ToORM(ctx context.Context) (InvestmentTransactionORM, error) {
	to := InvestmentTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Ammount = m.Ammount
	to.InvestmentTransactionId = m.InvestmentTransactionId
	to.SecurityId = m.SecurityId
	to.Date = m.Date
	to.Name = m.Name
	to.Quantity = m.Quantity
	to.Amount = m.Amount
	to.Price = m.Price
	to.Fees = m.Fees
	to.Type = m.Type
	to.Subtype = m.Subtype
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.UserId = m.UserId
	to.CreatedAt = m.CreatedAt
	to.Sign = m.Sign
	if posthook, ok := interface{}(m).(InvestmentTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestmentTransactionORM) ToPB(ctx context.Context) (InvestmentTransaction, error) {
	to := InvestmentTransaction{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Ammount = m.Ammount
	to.InvestmentTransactionId = m.InvestmentTransactionId
	to.SecurityId = m.SecurityId
	to.Date = m.Date
	to.Name = m.Name
	to.Quantity = m.Quantity
	to.Amount = m.Amount
	to.Price = m.Price
	to.Fees = m.Fees
	to.Type = m.Type
	to.Subtype = m.Subtype
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.UserId = m.UserId
	to.CreatedAt = m.CreatedAt
	to.Sign = m.Sign
	if posthook, ok := interface{}(m).(InvestmentTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvestmentTransaction the arg will be the target, the caller the one being converted from

// InvestmentTransactionBeforeToORM called before default ToORM code
type InvestmentTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestmentTransactionORM) error
}

// InvestmentTransactionAfterToORM called after default ToORM code
type InvestmentTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *InvestmentTransactionORM) error
}

// InvestmentTransactionBeforeToPB called before default ToPB code
type InvestmentTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvestmentTransaction) error
}

// InvestmentTransactionAfterToPB called after default ToPB code
type InvestmentTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *InvestmentTransaction) error
}

type ReOccuringTransactionORM struct {
	AccountId                       string
	AverageAmount                   string
	AverageAmountIsoCurrencyCode    string
	CategoryId                      string
	Description                     string
	FirstDate                       string
	Flow                            string
	Frequency                       string
	Id                              uint64
	IsActive                        bool
	LastAmount                      string
	LastAmountIsoCurrencyCode       string
	LastDate                        string
	LinkId                          uint64
	MerchantName                    string
	PersonalFinanceCategoryDetailed string
	PersonalFinanceCategoryPrimary  string
	Sign                            int32
	Status                          string
	StreamId                        string
	TransactionIds                  string
	UpdatedTime                     string
	UserId                          uint64
}

// TableName overrides the default tablename generated by GORM
func (ReOccuringTransactionORM) TableName() string {
	return "re_occuring_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ReOccuringTransaction) ToORM(ctx context.Context) (ReOccuringTransactionORM, error) {
	to := ReOccuringTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(ReOccuringTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.StreamId = m.StreamId
	to.CategoryId = m.CategoryId
	to.Description = m.Description
	to.MerchantName = m.MerchantName
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.FirstDate = m.FirstDate
	to.LastDate = m.LastDate
	to.Frequency = ReOccuringTransactionsFrequency_name[int32(m.Frequency)]
	to.TransactionIds = m.TransactionIds
	to.AverageAmount = m.AverageAmount
	to.AverageAmountIsoCurrencyCode = m.AverageAmountIsoCurrencyCode
	to.LastAmount = m.LastAmount
	to.LastAmountIsoCurrencyCode = m.LastAmountIsoCurrencyCode
	to.IsActive = m.IsActive
	to.Status = ReOccuringTransactionsStatus_name[int32(m.Status)]
	to.UpdatedTime = m.UpdatedTime
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.Flow = ReCurringFlow_name[int32(m.Flow)]
	to.Sign = m.Sign
	if posthook, ok := interface{}(m).(ReOccuringTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReOccuringTransactionORM) ToPB(ctx context.Context) (ReOccuringTransaction, error) {
	to := ReOccuringTransaction{}
	var err error
	if prehook, ok := interface{}(m).(ReOccuringTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.StreamId = m.StreamId
	to.CategoryId = m.CategoryId
	to.Description = m.Description
	to.MerchantName = m.MerchantName
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.FirstDate = m.FirstDate
	to.LastDate = m.LastDate
	to.Frequency = ReOccuringTransactionsFrequency(ReOccuringTransactionsFrequency_value[m.Frequency])
	to.TransactionIds = m.TransactionIds
	to.AverageAmount = m.AverageAmount
	to.AverageAmountIsoCurrencyCode = m.AverageAmountIsoCurrencyCode
	to.LastAmount = m.LastAmount
	to.LastAmountIsoCurrencyCode = m.LastAmountIsoCurrencyCode
	to.IsActive = m.IsActive
	to.Status = ReOccuringTransactionsStatus(ReOccuringTransactionsStatus_value[m.Status])
	to.UpdatedTime = m.UpdatedTime
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.Flow = ReCurringFlow(ReCurringFlow_value[m.Flow])
	to.Sign = m.Sign
	if posthook, ok := interface{}(m).(ReOccuringTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ReOccuringTransaction the arg will be the target, the caller the one being converted from

// ReOccuringTransactionBeforeToORM called before default ToORM code
type ReOccuringTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReOccuringTransactionORM) error
}

// ReOccuringTransactionAfterToORM called after default ToORM code
type ReOccuringTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *ReOccuringTransactionORM) error
}

// ReOccuringTransactionBeforeToPB called before default ToPB code
type ReOccuringTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *ReOccuringTransaction) error
}

// ReOccuringTransactionAfterToPB called after default ToPB code
type ReOccuringTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *ReOccuringTransaction) error
}

type TransactionORM struct {
	AccountId                       string
	AccountOwner                    string
	Amount                          float64
	AuthorizedDate                  string
	AuthorizedDatetime              string
	CategoryId                      string
	CheckNumber                     string
	Date                            string
	Datetime                        string
	Id                              uint64
	IsoCurrencyCode                 string
	LinkId                          uint64
	LocationAddress                 string
	LocationCity                    string
	LocationCountry                 string
	LocationLat                     float64
	LocationLon                     float64
	LocationPostalCode              string
	LocationRegion                  string
	LocationStoreNumber             string
	MerchantName                    string
	Name                            string
	PaymentChannel                  string
	PaymentMetaByOrderOf            string
	PaymentMetaPayee                string
	PaymentMetaPayer                string
	PaymentMetaPaymentMethod        string
	PaymentMetaPaymentProcessor     string
	PaymentMetaPpdId                string
	PaymentMetaReason               string
	PaymentMetaReferenceNumber      string
	Pending                         bool
	PendingTransactionId            string
	PersonalFinanceCategoryDetailed string
	PersonalFinanceCategoryPrimary  string
	Sign                            int32
	TransactionCode                 string
	TransactionId                   string
	UnofficialCurrencyCode          string
	UserId                          uint64
}

// TableName overrides the default tablename generated by GORM
func (TransactionORM) TableName() string {
	return "transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Transaction) ToORM(ctx context.Context) (TransactionORM, error) {
	to := TransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Amount = m.Amount
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.CategoryId = m.CategoryId
	to.CheckNumber = m.CheckNumber
	to.Date = m.Date
	to.Datetime = m.Datetime
	to.AuthorizedDate = m.AuthorizedDate
	to.AuthorizedDatetime = m.AuthorizedDatetime
	to.Name = m.Name
	to.MerchantName = m.MerchantName
	to.PaymentChannel = m.PaymentChannel
	to.Pending = m.Pending
	to.PendingTransactionId = m.PendingTransactionId
	to.AccountOwner = m.AccountOwner
	to.TransactionId = m.TransactionId
	to.TransactionCode = m.TransactionCode
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Sign = m.Sign
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.LocationAddress = m.LocationAddress
	to.LocationCity = m.LocationCity
	to.LocationRegion = m.LocationRegion
	to.LocationPostalCode = m.LocationPostalCode
	to.LocationCountry = m.LocationCountry
	to.LocationLat = m.LocationLat
	to.LocationLon = m.LocationLon
	to.LocationStoreNumber = m.LocationStoreNumber
	to.PaymentMetaByOrderOf = m.PaymentMetaByOrderOf
	to.PaymentMetaPayee = m.PaymentMetaPayee
	to.PaymentMetaPayer = m.PaymentMetaPayer
	to.PaymentMetaPaymentMethod = m.PaymentMetaPaymentMethod
	to.PaymentMetaPaymentProcessor = m.PaymentMetaPaymentProcessor
	to.PaymentMetaPpdId = m.PaymentMetaPpdId
	to.PaymentMetaReason = m.PaymentMetaReason
	to.PaymentMetaReferenceNumber = m.PaymentMetaReferenceNumber
	if posthook, ok := interface{}(m).(TransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionORM) ToPB(ctx context.Context) (Transaction, error) {
	to := Transaction{}
	var err error
	if prehook, ok := interface{}(m).(TransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Amount = m.Amount
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.CategoryId = m.CategoryId
	to.CheckNumber = m.CheckNumber
	to.Date = m.Date
	to.Datetime = m.Datetime
	to.AuthorizedDate = m.AuthorizedDate
	to.AuthorizedDatetime = m.AuthorizedDatetime
	to.Name = m.Name
	to.MerchantName = m.MerchantName
	to.PaymentChannel = m.PaymentChannel
	to.Pending = m.Pending
	to.PendingTransactionId = m.PendingTransactionId
	to.AccountOwner = m.AccountOwner
	to.TransactionId = m.TransactionId
	to.TransactionCode = m.TransactionCode
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Sign = m.Sign
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.LocationAddress = m.LocationAddress
	to.LocationCity = m.LocationCity
	to.LocationRegion = m.LocationRegion
	to.LocationPostalCode = m.LocationPostalCode
	to.LocationCountry = m.LocationCountry
	to.LocationLat = m.LocationLat
	to.LocationLon = m.LocationLon
	to.LocationStoreNumber = m.LocationStoreNumber
	to.PaymentMetaByOrderOf = m.PaymentMetaByOrderOf
	to.PaymentMetaPayee = m.PaymentMetaPayee
	to.PaymentMetaPayer = m.PaymentMetaPayer
	to.PaymentMetaPaymentMethod = m.PaymentMetaPaymentMethod
	to.PaymentMetaPaymentProcessor = m.PaymentMetaPaymentProcessor
	to.PaymentMetaPpdId = m.PaymentMetaPpdId
	to.PaymentMetaReason = m.PaymentMetaReason
	to.PaymentMetaReferenceNumber = m.PaymentMetaReferenceNumber
	if posthook, ok := interface{}(m).(TransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Transaction the arg will be the target, the caller the one being converted from

// TransactionBeforeToORM called before default ToORM code
type TransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionORM) error
}

// TransactionAfterToORM called after default ToORM code
type TransactionWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionORM) error
}

// TransactionBeforeToPB called before default ToPB code
type TransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *Transaction) error
}

// TransactionAfterToPB called after default ToPB code
type TransactionWithAfterToPB interface {
	AfterToPB(context.Context, *Transaction) error
}

// DefaultCreateInvestmentTransaction executes a basic gorm create call
func DefaultCreateInvestmentTransaction(ctx context.Context, in *InvestmentTransaction, db *gorm.DB) (*InvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvestmentTransaction(ctx context.Context, in *InvestmentTransaction, db *gorm.DB) (*InvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvestmentTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvestmentTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvestmentTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentTransaction(ctx context.Context, in *InvestmentTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvestmentTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvestmentTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentTransactionSet(ctx context.Context, in []*InvestmentTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvestmentTransactionORM{})).(InvestmentTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvestmentTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvestmentTransactionORM{})).(InvestmentTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvestmentTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvestmentTransaction, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvestmentTransaction, *gorm.DB) error
}

// DefaultStrictUpdateInvestmentTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvestmentTransaction(ctx context.Context, in *InvestmentTransaction, db *gorm.DB) (*InvestmentTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvestmentTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvestmentTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvestmentTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvestmentTransaction executes a basic gorm update call with patch behavior
func DefaultPatchInvestmentTransaction(ctx context.Context, in *InvestmentTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvestmentTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(InvestmentTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvestmentTransaction(ctx, &InvestmentTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvestmentTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvestmentTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvestmentTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvestmentTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvestmentTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvestmentTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvestmentTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvestmentTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvestmentTransaction(ctx context.Context, objects []*InvestmentTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvestmentTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvestmentTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvestmentTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvestmentTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestmentTransaction(ctx context.Context, patchee *InvestmentTransaction, patcher *InvestmentTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvestmentTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"Ammount" {
			patchee.Ammount = patcher.Ammount
			continue
		}
		if f == prefix+"InvestmentTransactionId" {
			patchee.InvestmentTransactionId = patcher.InvestmentTransactionId
			continue
		}
		if f == prefix+"SecurityId" {
			patchee.SecurityId = patcher.SecurityId
			continue
		}
		if f == prefix+"Date" {
			patchee.Date = patcher.Date
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"Price" {
			patchee.Price = patcher.Price
			continue
		}
		if f == prefix+"Fees" {
			patchee.Fees = patcher.Fees
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Subtype" {
			patchee.Subtype = patcher.Subtype
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"Sign" {
			patchee.Sign = patcher.Sign
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestmentTransaction executes a gorm list call
func DefaultListInvestmentTransaction(ctx context.Context, db *gorm.DB) ([]*InvestmentTransaction, error) {
	in := InvestmentTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvestmentTransactionORM{}, &InvestmentTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvestmentTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvestmentTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestmentTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvestmentTransactionORM) error
}

// DefaultCreateReOccuringTransaction executes a basic gorm create call
func DefaultCreateReOccuringTransaction(ctx context.Context, in *ReOccuringTransaction, db *gorm.DB) (*ReOccuringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReOccuringTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadReOccuringTransaction(ctx context.Context, in *ReOccuringTransaction, db *gorm.DB) (*ReOccuringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ReOccuringTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReOccuringTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReOccuringTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReOccuringTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteReOccuringTransaction(ctx context.Context, in *ReOccuringTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReOccuringTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReOccuringTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteReOccuringTransactionSet(ctx context.Context, in []*ReOccuringTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReOccuringTransactionORM{})).(ReOccuringTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReOccuringTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReOccuringTransactionORM{})).(ReOccuringTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReOccuringTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ReOccuringTransaction, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ReOccuringTransaction, *gorm.DB) error
}

// DefaultStrictUpdateReOccuringTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReOccuringTransaction(ctx context.Context, in *ReOccuringTransaction, db *gorm.DB) (*ReOccuringTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReOccuringTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReOccuringTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReOccuringTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchReOccuringTransaction executes a basic gorm update call with patch behavior
func DefaultPatchReOccuringTransaction(ctx context.Context, in *ReOccuringTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*ReOccuringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ReOccuringTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(ReOccuringTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReOccuringTransaction(ctx, &ReOccuringTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReOccuringTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReOccuringTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReOccuringTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReOccuringTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReOccuringTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReOccuringTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ReOccuringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ReOccuringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ReOccuringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ReOccuringTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetReOccuringTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetReOccuringTransaction(ctx context.Context, objects []*ReOccuringTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ReOccuringTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ReOccuringTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchReOccuringTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskReOccuringTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReOccuringTransaction(ctx context.Context, patchee *ReOccuringTransaction, patcher *ReOccuringTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ReOccuringTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"StreamId" {
			patchee.StreamId = patcher.StreamId
			continue
		}
		if f == prefix+"CategoryId" {
			patchee.CategoryId = patcher.CategoryId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"PersonalFinanceCategoryDetailed" {
			patchee.PersonalFinanceCategoryDetailed = patcher.PersonalFinanceCategoryDetailed
			continue
		}
		if f == prefix+"FirstDate" {
			patchee.FirstDate = patcher.FirstDate
			continue
		}
		if f == prefix+"LastDate" {
			patchee.LastDate = patcher.LastDate
			continue
		}
		if f == prefix+"Frequency" {
			patchee.Frequency = patcher.Frequency
			continue
		}
		if f == prefix+"TransactionIds" {
			patchee.TransactionIds = patcher.TransactionIds
			continue
		}
		if f == prefix+"AverageAmount" {
			patchee.AverageAmount = patcher.AverageAmount
			continue
		}
		if f == prefix+"AverageAmountIsoCurrencyCode" {
			patchee.AverageAmountIsoCurrencyCode = patcher.AverageAmountIsoCurrencyCode
			continue
		}
		if f == prefix+"LastAmount" {
			patchee.LastAmount = patcher.LastAmount
			continue
		}
		if f == prefix+"LastAmountIsoCurrencyCode" {
			patchee.LastAmountIsoCurrencyCode = patcher.LastAmountIsoCurrencyCode
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"UpdatedTime" {
			patchee.UpdatedTime = patcher.UpdatedTime
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Flow" {
			patchee.Flow = patcher.Flow
			continue
		}
		if f == prefix+"Sign" {
			patchee.Sign = patcher.Sign
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReOccuringTransaction executes a gorm list call
func DefaultListReOccuringTransaction(ctx context.Context, db *gorm.DB) ([]*ReOccuringTransaction, error) {
	in := ReOccuringTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReOccuringTransactionORM{}, &ReOccuringTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReOccuringTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ReOccuringTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReOccuringTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReOccuringTransactionORM) error
}

// DefaultCreateTransaction executes a basic gorm create call
func DefaultCreateTransaction(ctx context.Context, in *Transaction, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTransaction(ctx context.Context, in *Transaction, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTransaction(ctx context.Context, in *Transaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionSet(ctx context.Context, in []*Transaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TransactionORM{})).(TransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TransactionORM{})).(TransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Transaction, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Transaction, *gorm.DB) error
}

// DefaultStrictUpdateTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTransaction(ctx context.Context, in *Transaction, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTransaction executes a basic gorm update call with patch behavior
func DefaultPatchTransaction(ctx context.Context, in *Transaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Transaction
	var err error
	if hook, ok := interface{}(&pbObj).(TransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTransaction(ctx, &Transaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetTransaction(ctx context.Context, objects []*Transaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Transaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Transaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransaction(ctx context.Context, patchee *Transaction, patcher *Transaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Transaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
		if f == prefix+"CategoryId" {
			patchee.CategoryId = patcher.CategoryId
			continue
		}
		if f == prefix+"CheckNumber" {
			patchee.CheckNumber = patcher.CheckNumber
			continue
		}
		if f == prefix+"Date" {
			patchee.Date = patcher.Date
			continue
		}
		if f == prefix+"Datetime" {
			patchee.Datetime = patcher.Datetime
			continue
		}
		if f == prefix+"AuthorizedDate" {
			patchee.AuthorizedDate = patcher.AuthorizedDate
			continue
		}
		if f == prefix+"AuthorizedDatetime" {
			patchee.AuthorizedDatetime = patcher.AuthorizedDatetime
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"PaymentChannel" {
			patchee.PaymentChannel = patcher.PaymentChannel
			continue
		}
		if f == prefix+"Pending" {
			patchee.Pending = patcher.Pending
			continue
		}
		if f == prefix+"PendingTransactionId" {
			patchee.PendingTransactionId = patcher.PendingTransactionId
			continue
		}
		if f == prefix+"AccountOwner" {
			patchee.AccountOwner = patcher.AccountOwner
			continue
		}
		if f == prefix+"TransactionId" {
			patchee.TransactionId = patcher.TransactionId
			continue
		}
		if f == prefix+"TransactionCode" {
			patchee.TransactionCode = patcher.TransactionCode
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Sign" {
			patchee.Sign = patcher.Sign
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"PersonalFinanceCategoryDetailed" {
			patchee.PersonalFinanceCategoryDetailed = patcher.PersonalFinanceCategoryDetailed
			continue
		}
		if f == prefix+"LocationAddress" {
			patchee.LocationAddress = patcher.LocationAddress
			continue
		}
		if f == prefix+"LocationCity" {
			patchee.LocationCity = patcher.LocationCity
			continue
		}
		if f == prefix+"LocationRegion" {
			patchee.LocationRegion = patcher.LocationRegion
			continue
		}
		if f == prefix+"LocationPostalCode" {
			patchee.LocationPostalCode = patcher.LocationPostalCode
			continue
		}
		if f == prefix+"LocationCountry" {
			patchee.LocationCountry = patcher.LocationCountry
			continue
		}
		if f == prefix+"LocationLat" {
			patchee.LocationLat = patcher.LocationLat
			continue
		}
		if f == prefix+"LocationLon" {
			patchee.LocationLon = patcher.LocationLon
			continue
		}
		if f == prefix+"LocationStoreNumber" {
			patchee.LocationStoreNumber = patcher.LocationStoreNumber
			continue
		}
		if f == prefix+"PaymentMetaByOrderOf" {
			patchee.PaymentMetaByOrderOf = patcher.PaymentMetaByOrderOf
			continue
		}
		if f == prefix+"PaymentMetaPayee" {
			patchee.PaymentMetaPayee = patcher.PaymentMetaPayee
			continue
		}
		if f == prefix+"PaymentMetaPayer" {
			patchee.PaymentMetaPayer = patcher.PaymentMetaPayer
			continue
		}
		if f == prefix+"PaymentMetaPaymentMethod" {
			patchee.PaymentMetaPaymentMethod = patcher.PaymentMetaPaymentMethod
			continue
		}
		if f == prefix+"PaymentMetaPaymentProcessor" {
			patchee.PaymentMetaPaymentProcessor = patcher.PaymentMetaPaymentProcessor
			continue
		}
		if f == prefix+"PaymentMetaPpdId" {
			patchee.PaymentMetaPpdId = patcher.PaymentMetaPpdId
			continue
		}
		if f == prefix+"PaymentMetaReason" {
			patchee.PaymentMetaReason = patcher.PaymentMetaReason
			continue
		}
		if f == prefix+"PaymentMetaReferenceNumber" {
			patchee.PaymentMetaReferenceNumber = patcher.PaymentMetaReferenceNumber
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransaction executes a gorm list call
func DefaultListTransaction(ctx context.Context, db *gorm.DB) ([]*Transaction, error) {
	in := Transaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionORM{}, &Transaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Transaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionORM) error
}
